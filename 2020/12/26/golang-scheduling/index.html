<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Golang Scheduling</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.



GPM 模型
调度流程
用户方式阻塞/唤醒
syscall
sysmon
抢占式调度
netpoll
g 的创建流程
g 的暂停方式
Go 调度查看方式
总结
参考链接

GPM 模型文件位置: src/runtime/runtime2.go

g(goroutine): 对应到 g 结构体, 保存 goroutin 需要的堆栈信息
p(process):   相当于 g 的驱动, 只有绑定在 local runq 下, 才能被调度
m(machine):   OS 线程抽象, 真正的驱动力, 和某个 p 绑定, 然后 p 从 local runq 中依次取出 g 用来执行


补充:

最早 go1.1.."><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Haojen's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Golang Scheduling</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPM-%E6%A8%A1%E5%9E%8B"><span class="toc-text">GPM 模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-text">调度流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%96%B9%E5%BC%8F%E9%98%BB%E5%A1%9E-%E5%94%A4%E9%86%92"><span class="toc-text">用户方式阻塞&#x2F;唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#syscall"><span class="toc-text">syscall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysmon"><span class="toc-text">sysmon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-text">抢占式调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netpoll"><span class="toc-text">netpoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">g 的创建流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g-%E7%9A%84%E6%9A%82%E5%81%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">g 的暂停方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E8%B0%83%E5%BA%A6%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F"><span class="toc-text">Go 调度查看方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/golang"><i class="tag post-item-tag">golang</i></a><a href="/tags/scheduling"><i class="tag post-item-tag">scheduling</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Golang Scheduling</h1><time class="has-text-grey" datetime="2020-12-26T15:40:47.000Z">2020-12-26</time><article class="mt-2 post-content"><p>熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.</p>
<a id="more"></a>

<ul>
<li><a href="#gpm-%E6%A8%A1%E5%9E%8B">GPM 模型</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B">调度流程</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E6%96%B9%E5%BC%8F%E9%98%BB%E5%A1%9E%E5%94%A4%E9%86%92">用户方式阻塞/唤醒</a></li>
<li><a href="#syscall">syscall</a></li>
<li><a href="#sysmon">sysmon</a></li>
<li><a href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6">抢占式调度</a></li>
<li><a href="#netpoll">netpoll</a></li>
<li><a href="#g-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B">g 的创建流程</a></li>
<li><a href="#g-%E7%9A%84%E6%9A%82%E5%81%9C%E6%96%B9%E5%BC%8F">g 的暂停方式</a></li>
<li><a href="#go-%E8%B0%83%E5%BA%A6%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F">Go 调度查看方式</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><p>文件位置: src/runtime/runtime2.go</p>
<ul>
<li>g(goroutine): 对应到 g 结构体, 保存 goroutin 需要的堆栈信息</li>
<li>p(process):   相当于 g 的驱动, 只有绑定在 local runq 下, 才能被调度</li>
<li>m(machine):   OS 线程抽象, 真正的驱动力, 和某个 p 绑定, 然后 p 从 local runq 中依次取出 g 用来执行</li>
</ul>
<p><img src="/../img/go-shechduling.png" alt="go-sheduling"></p>
<p>补充:</p>
<ol>
<li>最早 go1.1 仅仅是 GM 模式, 后续 Dmitry Vyukov 为了解决<strong>并发伸缩性</strong>问题, 引入 p 的概念 <a target="_blank" rel="noopener" href="https://github.com/muzig/muzig.github.io/blob/main/source/pdf/Scalable%20Go%20Scheduler%20Design%20Doc.pdf">提案文档</a></li>
<li>g 的数量受限于 GOMAXPROCS, 即超线程数量, 一般 intel cpu 具有超线程技术, 双核四线程, 即数量为4</li>
<li>m 的个数是不定的，由Go Runtime调整，默认最大限制为10000个</li>
</ol>
<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><ol>
<li>m 与 p 绑定, m 从 p 的 local runq 中取出并切换到 g 的堆栈执行<ol>
<li>若 local runq 存在 g, 则执行(无锁)</li>
<li>若不存在, 从 global runq 取出 g 执行(有锁)</li>
<li>若依然不存在, 则从其他 p “窃取” g 执行</li>
</ol>
</li>
<li>若没有 g 可以执行, 则 m 与 p 解绑, 进入休眠模式(idle)</li>
</ol>
<h2 id="用户方式阻塞-唤醒"><a href="#用户方式阻塞-唤醒" class="headerlink" title="用户方式阻塞/唤醒"></a>用户方式阻塞/唤醒</h2><p>阻塞:</p>
<p>当 g 被 channel 卡住, m 会跳过执行下一个, 并将 g 放置在 waitq 里面</p>
<p>唤醒:</p>
<p>当 g 执行的时候, 通过 channel 向另一个 g2 投递消息, 则 g2 将直接”插队”, 放下一个执行</p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>若 g 被阻塞在一个系统调用上, 则 p 将于 m 解绑, 寻找 idle 状态的 m 再此绑定; 若没有 idle 状态的 m, 则创建一个新的 m.</p>
<p>系统调用结束, g 会重新寻找 idle 状态的 p, 并恢复执行, 若没有则放到 globl runq 中.</p>
<p>系统被调度的两个关键点:</p>
<ol>
<li>runtime/syscall包中, 系统调用分为 syscall &amp; rawsyscall, 区别在于前者会记录保存和恢复所需状态, 这样可以安全的解绑; 某些系统调用可以预先评估是会长时间阻塞, 则会发起之前, 直接 p &amp; m 解绑(handoffp)</li>
<li>sysmon 负责检查系统调用时间, 决定是否需要 handoffp</li>
</ol>
<h2 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h2><p>sysmon 是一个由 runtime 启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次.</p>
<p>流程如下:</p>
<ol>
<li>释放闲置超过5分钟的span物理内存；</li>
<li>如果超过2分钟没有垃圾回收，强制执行；</li>
<li>将长时间未处理的netpoll结果添加到任务队列；</li>
<li>向长时间运行的G任务发出抢占调度；</li>
<li>收回因syscall长时间阻塞的P；</li>
</ol>
<h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p>当某个 g 执行超过10ms, 则 sysmon 将发起抢占式请求, 会给 g 打上标签; 当 g 执行函数时(更确切说，在通过newstack分配函数栈时), 将被 runtime.Goched 的方式暂停, 放置在 global runq 中</p>
<h2 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h2><p>除了之前提到的, local runq, runqnext, global runq, 还存在对网络 I/O 进行优化的 netpoll, 本地避免网络I/O的时候陷入系统调用, 不阻塞 M (而是阻塞 G ), 从而不会导致大量的 M 被创建</p>
<h2 id="g-的创建流程"><a href="#g-的创建流程" class="headerlink" title="g 的创建流程"></a>g 的创建流程</h2><ol>
<li>当 go func(){} 执行的时候, 会尝试从池子中复用, 没有则创建</li>
<li>尝试”插队”, 放置到当前 p 的 runnext 里面</li>
<li>否则放置到 local runq 中(无锁)</li>
<li>否则放置到 global runq 中(有锁)</li>
</ol>
<h2 id="g-的暂停方式"><a href="#g-的暂停方式" class="headerlink" title="g 的暂停方式"></a>g 的暂停方式</h2><ul>
<li>常规方式  - 将 g 阻塞, 放到 global runq 中, 等待被获取执行</li>
<li>等待方式  - 将 g 阻塞, 放到 waitq 中, 等待被其他 g 唤醒</li>
<li>自旋方式  - gpm 都不调度, 直到被唤醒</li>
<li>退出方式  - 立即终止 g 任务, 确保 defer 正常执行</li>
<li>process 方式 - 放飞 p, 阻塞 g m, p 可以跟其他 m 绑定</li>
</ul>
<h2 id="Go-调度查看方式"><a href="#Go-调度查看方式" class="headerlink" title="Go 调度查看方式"></a>Go 调度查看方式</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wudaijun.com/2018/01/go-scheduler/">Go 调度模型</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从调度模型, 到 gpm 的探讨, 讲到了阻塞和唤醒的流程, 以及如何抢占, 延伸到 sysmon 服务的特点; 最后补充了 netpoll 优化和 g 的创建流程和状态介绍.<br>回过头来, 我们再看看, 学习调度的目的其实实际需求来讲, 就是编写更加高效的并发程序, 明白了流程, 还需要实战, 后续再更新代码实战的情况.</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wudaijun.com/2018/01/go-scheduler/">Go 调度模型</a></li>
<li><a target="_blank" rel="noopener" href="https://wudaijun.com/2018/11/scheduler-blabla/">再谈调度</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/db0aea4d60ed">达菲格-Go 语言调度（一）: 系统调度</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb6881a2661d">达菲格-Go 语言调度（二）: goroutine 调度器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ef654413f2c1">达菲格-Go 语言调度（三）: 并发</a></li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/12/26/golang-GC/" title="Golang GC"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Golang GC</span></a><a class="button is-default" href="/2020/12/19/shell-note/" title="Shell 笔记"><span class="has-text-weight-semibold">Next: Shell 笔记</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/haojen"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Haojen 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>