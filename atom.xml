<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://muzig.github.io/atom.xml" rel="self"/>
  
  <link href="http://muzig.github.io/"/>
  <updated>2021-01-30T06:00:00.949Z</updated>
  <id>http://muzig.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tmux 快速指北</title>
    <link href="http://muzig.github.io/2021/01/30/tmux/"/>
    <id>http://muzig.github.io/2021/01/30/tmux/</id>
    <published>2021-01-30T09:52:48.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>如果您用过screen的话, 相比知道它的好处, 这里记录一款类似的工具tmux.</p><a id="more"></a><ul><li><a href="#todo">TODO</a></li><li><a href="#-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA">🚀 快速搭建</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE">常用快捷键</a></li><li><a href="#%E6%8F%92%E4%BB%B6">插件</a><ul><li><a href="#oh-my-tmux">oh-my-tmux</a></li><li><a href="#tmux-resurrect">tmux-resurrect</a></li></ul></li><li><a href="#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5">友情链接</a></li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled type="checkbox"> 常用快捷键</li></ul><h2 id="🚀-快速搭建"><a href="#🚀-快速搭建" class="headerlink" title="🚀 快速搭建"></a>🚀 快速搭建</h2><ul><li>Install Tmux:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mac</span></span><br><span class="line">brew install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux - RedHat</span></span><br><span class="line">yum install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux - Debian</span></span><br><span class="line">apt install tmux</span><br></pre></td></tr></table></figure><ul><li>Clone TPM:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</span><br></pre></td></tr></table></figure><ul><li>Put this at the bottom of ~/.tmux.conf ($XDG_CONFIG_HOME/tmux/tmux.conf works too):</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gpakosz/.tmux.git ~/.tmux/oh-my-tmux/</span><br><span class="line">cp ~/.tmux/oh-my-tmux/.tmux.conf ~/</span><br></pre></td></tr></table></figure><ul><li>Reload TMUX environment so TPM is sourced:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type this in terminal if tmux is already running</span></span><br><span class="line">$ tmux <span class="built_in">source</span> ~/.tmux.conf</span><br></pre></td></tr></table></figure><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="oh-my-tmux"><a href="#oh-my-tmux" class="headerlink" title="oh-my-tmux"></a>oh-my-tmux</h3><p>作用: 通用tmux配置搭配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gpakosz/.tmux.git</span><br><span class="line">ln -s -f .tmux/.tmux.conf</span><br><span class="line">cp .tmux/.tmux.conf.local .</span><br></pre></td></tr></table></figure><h3 id="tmux-resurrect"><a href="#tmux-resurrect" class="headerlink" title="tmux-resurrect"></a>tmux-resurrect</h3><p>作用: 保存tmux的layout, 便于重启电脑快速恢复.</p><ul><li>Add plugin to the list of TPM plugins in .tmux.conf:</li><li>Hit prefix + I to fetch the plugin and source it. You should now be able to use the plugin.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-resurrect&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><ul><li><a href="https://github.com/tmux-plugins/tpm">TPM</a></li><li><a href="https://github.com/gpakosz/.tmux">oh-my-tmux</a></li><li><a href="https://github.com/tmux-plugins/tmux-resurrect">tmux-resurrect</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果您用过screen的话, 相比知道它的好处, 这里记录一款类似的工具tmux.&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="tmux" scheme="http://muzig.github.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>vue.js 纪录片</title>
    <link href="http://muzig.github.io/2021/01/29/the-documentary-of-vue/"/>
    <id>http://muzig.github.io/2021/01/29/the-documentary-of-vue/</id>
    <published>2021-01-29T21:19:57.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>值得一看. <a href="https://www.youtube.com/watch?v=OrxmtDw4pVI">Click Here</a></p><a id="more"></a><p><img src="/../img/vue01.png" alt="vue.jd"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;值得一看. &lt;a href=&quot;https://www.youtube.com/watch?v=OrxmtDw4pVI&quot;&gt;Click Here&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://muzig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue.js" scheme="http://muzig.github.io/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中高级技术</title>
    <link href="http://muzig.github.io/2021/01/24/golang-senior-interview/"/>
    <id>http://muzig.github.io/2021/01/24/golang-senior-interview/</id>
    <published>2021-01-24T21:38:41.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>之前有了初级技术, 接下来总结一下关于中高级开发的技术要求</p><a id="more"></a><ul><li><a href="#todo">TODO</a></li><li><a href="#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5">友情链接</a></li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>后续再俩梳理, 目前看了一遍发现自己真的基础太欠缺了, 对于底层的实现机制来说, 还有很多需要涉猎, 不过其实对于开发来说, 涉及面其实少.</p><p>后面要注重代码的性能分析, 以及代码开发效率和质量相关问题的分析, 个人排序: 开发质量(易查错, 健壮性) &gt; 开发效率 &gt; 性能</p><ul><li><input disabled type="checkbox"> 整理文档</li></ul><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><ul><li><a href="https://www.bilibili.com/video/BV12p4y1W7Dz">中高级Golang</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前有了初级技术, 接下来总结一下关于中高级开发的技术要求&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://muzig.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="golang" scheme="http://muzig.github.io/tags/golang/"/>
    
    <category term="interview" scheme="http://muzig.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>raspberryPi 入门</title>
    <link href="http://muzig.github.io/2021/01/23/raspberryPi-note/"/>
    <id>http://muzig.github.io/2021/01/23/raspberryPi-note/</id>
    <published>2021-01-23T21:54:28.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>之前在储备前端技术, 目前使用树莓派来搭建开发环境, 便于测试.</p><a id="more"></a><ul><li><a href="#todo">TODO</a></li><li><a href="#%E8%B4%AD%E4%B9%B0%E5%BB%BA%E8%AE%AE">购买建议</a></li><li><a href="#%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8">初次使用</a></li><li><a href="#%E5%88%9D%E6%AC%A1%E5%90%AF%E5%8A%A8">初次启动</a></li><li><a href="#%E5%BF%85%E4%BC%9A%E5%91%BD%E4%BB%A4">必会命令</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAlamp%E7%8E%AF%E5%A2%83">如何搭建LAMP环境</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">如何搭建开发环境</a></li><li><a href="#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5">友情链接</a></li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled type="checkbox"> 完善文档</li></ul><h2 id="购买建议"><a href="#购买建议" class="headerlink" title="购买建议"></a>购买建议</h2><h2 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h2><h2 id="初次启动"><a href="#初次启动" class="headerlink" title="初次启动"></a>初次启动</h2><h2 id="必会命令"><a href="#必会命令" class="headerlink" title="必会命令"></a>必会命令</h2><h2 id="如何搭建LAMP环境"><a href="#如何搭建LAMP环境" class="headerlink" title="如何搭建LAMP环境"></a>如何搭建LAMP环境</h2><h2 id="如何搭建开发环境"><a href="#如何搭建开发环境" class="headerlink" title="如何搭建开发环境"></a>如何搭建开发环境</h2><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/59027897">如何给树莓派安装操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在储备前端技术, 目前使用树莓派来搭建开发环境, 便于测试.&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="raspberryPi" scheme="http://muzig.github.io/tags/raspberryPi/"/>
    
  </entry>
  
  <entry>
    <title>Vue 笔记</title>
    <link href="http://muzig.github.io/2021/01/16/vue-note/"/>
    <id>http://muzig.github.io/2021/01/16/vue-note/</id>
    <published>2021-01-16T16:32:05.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>将自学思路整理此处, 便于后续细节回顾.</p><a id="more"></a><ul><li><a href="#%E6%BA%90%E7%A0%81%E9%A1%B9%E7%9B%AE">源码项目</a></li><li><a href="#%E6%8A%80%E6%9C%AF%E6%A0%88">技术栈</a></li></ul><h2 id="源码项目"><a href="#源码项目" class="headerlink" title="源码项目"></a>源码项目</h2><p>在了解基本语法之后, 最好的学习方式就是熟悉实战项目的源码, 能较快的获取实战经验.</p><p>此处贴 github 开源的实战项目, 很值的一探究竟.</p><ul><li><a href="https://github.com/bailicangdu/vue2-elm">外卖实战项目</a></li><li><a href="https://github.com/bailicangdu/vue2-manage">外卖后端管理</a></li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>有了实战项目, 我们先了解一下我们将用到什么工具, 这样对整个开发过程有一个大局观的感觉.</p><ul><li>vue2</li><li>vuex</li><li>vue-router</li><li>webpack</li><li>ES6/7</li><li>fetch</li><li>sass</li><li>flex</li><li>svg</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;将自学思路整理此处, 便于后续细节回顾.&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://muzig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://muzig.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 笔记</title>
    <link href="http://muzig.github.io/2021/01/10/ts-note/"/>
    <id>http://muzig.github.io/2021/01/10/ts-note/</id>
    <published>2021-01-10T19:16:43.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>对于需要掌握前端技术, 对于 ts 的基础语法掌握也是必不可少的. 利于读懂前端源码.</p><a id="more"></a><ul><li><a href="#todo">TODO</a></li><li><a href="#%E9%80%9F%E8%A7%88">速览</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B">基础类型</a><ul><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E5%85%83%E7%BB%84-tuple">元组 Tuple</a></li><li><a href="#%E6%9E%9A%E4%B8%BE">枚举</a></li><li><a href="#void">Void</a></li><li><a href="#null--undefined">null &amp; undefined</a></li><li><a href="#never">Never</a></li><li><a href="#object">Object</a></li><li><a href="#any">Any</a></li><li><a href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">类型断言</a></li><li><a href="#%E5%85%B3%E4%BA%8Elet">关于let</a></li></ul></li><li><a href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">变量声明</a><ul><li><a href="#var%E5%A3%B0%E6%98%8E">var声明</a></li><li><a href="#let%E5%A3%B0%E6%98%8E">let声明</a></li><li><a href="#const%E5%A3%B0%E6%98%8E">const声明</a></li><li><a href="#%E8%A7%A3%E6%9E%84">解构</a><ul><li><a href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84">数组解构</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84">对象解构</a></li></ul></li><li><a href="#%E5%B1%95%E5%BC%80%E4%B8%8E%E8%A7%A3%E6%9E%84%E7%9B%B8%E5%8F%8D%E6%93%8D%E4%BD%9C">展开(与解构相反操作)</a><ul><li><a href="#%E6%95%B0%E7%BB%84%E5%B1%95%E5%BC%80">数组展开</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80">对象展开</a></li></ul></li></ul></li><li><a href="#%E6%8E%A5%E5%8F%A3">接口</a><ul><li><a href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89">接口定义</a></li><li><a href="#%E5%BD%A2%E5%8F%82%E7%BA%A6%E6%9D%9F">形参约束</a></li><li><a href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0">可选参数</a></li><li><a href="#%E5%8F%AA%E8%AF%BB%E5%8F%82%E6%95%B0">只读参数</a></li><li><a href="#%E5%85%B3%E9%97%AD%E9%A2%9D%E5%A4%96%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">关闭额外类型检查</a></li><li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B">函数类型</a></li><li><a href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B">可索引的类型</a></li><li><a href="#%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3">类继承接口</a></li><li><a href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF">接口继承</a></li><li><a href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B">混合类型</a></li><li><a href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB">接口继承类</a></li></ul></li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked disabled type="checkbox"> 速览</li><li><input checked disabled type="checkbox"> 基础类型</li><li><input checked disabled type="checkbox"> 变量声明</li><li><input checked disabled type="checkbox"> 接口</li><li><input disabled type="checkbox"> 函数</li><li><input disabled type="checkbox"> 泛型</li><li><input disabled type="checkbox"> 枚举</li><li><input disabled type="checkbox"> 类型推导</li><li><input disabled type="checkbox"> 类型兼容性</li><li><input disabled type="checkbox"> 高级类型</li><li><input disabled type="checkbox"> Symbols</li><li><input disabled type="checkbox"> 迭代器和生成器</li><li><input disabled type="checkbox"> 模块</li><li><input disabled type="checkbox"> 命令空间</li><li><input disabled type="checkbox"> 命令空间和模块</li><li><input disabled type="checkbox"> 模块解析</li><li><input disabled type="checkbox"> 声明合并</li><li><input disabled type="checkbox"> JSX</li><li><input disabled type="checkbox"> 装饰器</li><li><input disabled type="checkbox"> Mixins</li><li><input disabled type="checkbox"> 三斜线指令</li><li><input disabled type="checkbox"> JS文件类型检查</li></ul><h2 id="速览"><a href="#速览" class="headerlink" title="速览"></a>速览</h2><ul><li><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">官方手册指南</a></p></li><li><p>类型注解</p></li></ul><p>ts 支持静态类型检查, 便于在运行之前, 提前发现代码问题.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="string">&quot;ts&quot;</span>;</span><br><span class="line">hello(flag);</span><br></pre></td></tr></table></figure><ul><li>接口</li></ul><p>执行约束 object 类型的格式, 便于保证函数按照预期执行</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">p: Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.firstName + p.lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">firstName</span>: <span class="string">&quot;xiao&quot;</span>, <span class="attr">lastName</span>: <span class="string">&quot;ming&quot;</span> &#125;;</span><br><span class="line">say(user);</span><br></pre></td></tr></table></figure><ul><li>类</li></ul><p>提供面向对象编程的思想, 具体更多抽象能力</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  fullName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> firstName: <span class="built_in">string</span>, <span class="keyword">public</span> lastName: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fullName = firstName + lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">p: Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.firstName + p.lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> Student(<span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;ming&quot;</span>);</span><br><span class="line">say(user);</span><br></pre></td></tr></table></figure><ul><li>补充</li></ul><blockquote><p>ts &amp; js 对大小写敏感; 对于属性名建议取名为小写, 因为 typeof 返回的类型名为小写.</p></blockquote><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&quot;TypeScript&quot;</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello <span class="subst">$&#123; name &#125;</span>.`</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 泛型数组</span></span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组 Tuple</span></span><br><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>更好的描述一组数值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认从0开始为元素编号</span></span><br><span class="line"><span class="comment">// 支持手动赋值</span></span><br><span class="line"><span class="built_in">enum</span> Color &#123; Red, Green, Blue = <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持打印枚举名</span></span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>] </span><br><span class="line"><span class="built_in">console</span>.log(colorName)</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Color</span></span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null</p><h3 id="null-amp-undefined"><a href="#null-amp-undefined" class="headerlink" title="null &amp; undefined"></a>null &amp; undefined</h3><p>然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。</p><blockquote><p>注意：我们鼓励尽可能地使用–strictNullChecks</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。</p><p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）.</p><p>即使 any也不可以赋值给never。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line">create(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>对于暂时无法预期的类型, 可以使用 any 去描述</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg: <span class="built_in">any</span> = <span class="number">100</span></span><br><span class="line">msg = <span class="literal">true</span> <span class="comment">// OK</span></span><br><span class="line">msg = <span class="string">&quot;foo&quot;</span> <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;boo&quot;</span>]</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">100</span> <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><blockquote><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法: 尖括号</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法: as语法</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><h3 id="关于let"><a href="#关于let" class="headerlink" title="关于let"></a>关于let</h3><p>你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a>var声明</h3><ul><li>作用域规则</li><li>捕获变量特殊之处</li></ul><h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><ul><li>块作用域</li><li>重定义屏蔽</li><li>块级作用域变量获取 - 通过闭包</li></ul><h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3><ul><li>声明之后不能修改; 但是可以修改对象内部值</li></ul><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><ul><li>让数组变量更清晰</li><li>支持函数参数解构格式</li><li>支持…语法创建剩余变量</li></ul><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><ul><li>结构化对象成员</li><li>…语法支持结构余下对象成员</li><li>支持结构化之后重命名</li><li>=语法支持缺省默认值</li><li>函数声明支持结构对象</li></ul><h3 id="展开-与解构相反操作"><a href="#展开-与解构相反操作" class="headerlink" title="展开(与解构相反操作)"></a>展开(与解构相反操作)</h3><h4 id="数组展开"><a href="#数组展开" class="headerlink" title="数组展开"></a>数组展开</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h4 id="对象展开"><a href="#对象展开" class="headerlink" title="对象展开"></a>对象展开</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">object</span> = &#123; <span class="attr">a</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;b&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2: <span class="built_in">object</span> = &#123; ...obj, <span class="attr">a</span>: <span class="string">&quot;b&quot;</span> &#125;; <span class="comment">// 不会重写 a 成员值 =&gt; a = &quot;b&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj2: <span class="built_in">object</span> = &#123; <span class="attr">a</span>: <span class="string">&quot;b&quot;</span>, ...obj &#125;; <span class="comment">// 会重写 a 成员值 =&gt; a = &quot;a&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><blockquote><p>对象展开还有其它一些意想不到的限制</p></blockquote><ul><li>扩展之后, 会丢失了成员函数</li><li>tsc不允许展开泛型函数上的类型参数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  p = <span class="number">12</span>;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;;</span><br><span class="line">clone.p; <span class="comment">// ok</span></span><br><span class="line">clone.m(); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><h3 id="形参约束"><a href="#形参约束" class="headerlink" title="形参约束"></a>形参约束</h3><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><h3 id="只读参数"><a href="#只读参数" class="headerlink" title="只读参数"></a>只读参数</h3><h3 id="关闭额外类型检查"><a href="#关闭额外类型检查" class="headerlink" title="关闭额外类型检查"></a>关闭额外类型检查</h3><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><blockquote><p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p></blockquote><h3 id="类继承接口"><a href="#类继承接口" class="headerlink" title="类继承接口"></a>类继承接口</h3><blockquote><p>类静态部分, 需要使用形参约束的方式去约束, 比如构造函数</p></blockquote><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><ul><li>extends</li><li>implements</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于需要掌握前端技术, 对于 ts 的基础语法掌握也是必不可少的. 利于读懂前端源码.&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://muzig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ts" scheme="http://muzig.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Golang 初级技术</title>
    <link href="http://muzig.github.io/2020/12/27/golang-primary-interview/"/>
    <id>http://muzig.github.io/2020/12/27/golang-primary-interview/</id>
    <published>2020-12-27T20:18:15.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要答辩, 收集了部分来自各方的实战面试内容, 便于巩固.</p><p><strong>如有不当之处，请予指正 🙏.</strong></p><a id="more"></a><ul><li><a href="#todo">TODO</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E7%AF%87">基础篇</a></li><li><a href="#%E6%A6%82%E5%BF%B5%E7%AF%87">概念篇</a></li><li><a href="#%E6%A1%86%E6%9E%B6%E7%AF%87">框架篇</a><ul><li><a href="#%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6">开源框架</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87">数据库篇</a></li><li><a href="#%E7%BA%BF%E4%B8%8A%E7%BB%8F%E9%AA%8C">线上经验</a></li><li><a href="#%E7%BC%96%E7%A8%8B%E9%A2%98">编程题</a><ul><li><a href="#%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E6%A3%80%E6%9F%A5">实现字符串匹配检查</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%A7%8D%E6%88%96%E5%A4%9A%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">实现一种或多种负载均衡算法</a></li></ul></li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled type="checkbox"> 尽可能完善题目答案</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.bilibili.com/video/BV1yy4y1v7ad">ShowMeBug-初级 Golang 面试视频</a></li></ul><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><blockquote><p>new 和 make 的区别?</p></blockquote><p>都是用于<strong>分配内存</strong>, 区别在于:</p><p>前者主要用于创建返回类型的指针引用;</p><p>后者只能用于 slice / map / channel 的初始化.</p><p>补充: 其实 new 不常用, 相比较下字面量初始化的方式更为常用, 同时获取指针引用之后, 对于对象的赋值, 还会导致<a href="./golang-escape-analysis.md">间接赋值的逃逸问题</a></p><blockquote><p>函数调用传引用类型还是值类型? (涉及逃逸问题)</p></blockquote><p>一般采用引用类型, 少数采用值类型, 这里主要参考的是: 函数内需要或者不需要修改引用类型的值;</p><p>其他情况考虑逃逸的问题, 若函数是变量, 则函数参数是引用的话, 会导致<a href="./golang-escape-analysis.md">函数变量逃逸</a>.</p><blockquote><p>反射的原理? (如何解析 struct 的 tag)</p></blockquote><blockquote><p>recover 能捕获子 goroutine 的 panic 吗?</p></blockquote><blockquote><p>锁相关的使用情况?</p></blockquote><blockquote><p>自己使用 channel 的使用场景以及坑?</p></blockquote><h2 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h2><blockquote><p>内存管理</p></blockquote><ol><li>线程协程的占用内存大小?</li></ol><blockquote><p>进程模型</p></blockquote><ol><li>进程状态转换</li></ol><blockquote><p>线程模型</p></blockquote><ol><li>线程如果发生 OOM 如何排查处理? 同理 goroutine 发生 OOM ?</li></ol><blockquote><p>调度逻辑</p></blockquote><ol><li>什么时候 goroutine 阻塞? 调度器如何处理?</li><li>goroutine 一直占用资源如何处理?</li></ol><h2 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h2><blockquote><p>项目中如何错误处理?</p></blockquote><blockquote><p>会自定义 error 错误处理吗?</p></blockquote><blockquote><p>gRPC 使用情况? 服务发现/负债均衡的实现?</p></blockquote><blockquote><p>proto 文件如何管理? (monorepo 尝试)</p></blockquote><blockquote><p>如果中心节点挂掉如何处理? (Raft算法保证可靠性)</p></blockquote><h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3><p>Web:</p><ul><li><a href="https://github.com/gin-gonic/gin">gin</a></li><li><a href="https://github.com/beego/beego">beego</a></li></ul><blockquote><p>Gin 中的自定义参数校验规则?</p></blockquote><blockquote><p>Gin 中间件的使用情况</p></blockquote><p>Game:</p><ul><li><a href="https://github.com/name5566/leaf">leaf</a></li><li><a href="https://github.com/duanhf2012/origin">origin</a></li></ul><blockquote><p>leaf 的消息路由方式?</p></blockquote><h2 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h2><ul><li>mongodb</li><li>mysql</li><li>redis</li></ul><blockquote><p>redis mongodb mysql 的锁机制?</p></blockquote><blockquote><p>redis 的基本内容, 使用情况?</p></blockquote><blockquote><p>redis 持久性如何处理?</p></blockquote><blockquote><p>mysql ORM使用情况? (XORM / GORM)</p></blockquote><blockquote><p>mysql 分库分表情况? (分片存储, HBase存储)</p></blockquote><blockquote><p>主从模式/集群模式/哨兵模式区别?</p></blockquote><h2 id="线上经验"><a href="#线上经验" class="headerlink" title="线上经验"></a>线上经验</h2><blockquote><p>线上 bug 如何排查?</p></blockquote><blockquote><p>如何分析线上性能瓶颈?</p></blockquote><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="实现字符串匹配检查"><a href="#实现字符串匹配检查" class="headerlink" title="实现字符串匹配检查"></a>实现字符串匹配检查</h3><p>正确输出以下结果: 即需要同时成对的符号, 即判断成功</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;[()]&quot;  =&gt; true</span><br><span class="line">&quot;[(]&quot;   =&gt; false</span><br><span class="line">&quot;&#123;]]&quot;   =&gt; false</span><br></pre></td></tr></table></figure><h3 id="实现一种或多种负载均衡算法"><a href="#实现一种或多种负载均衡算法" class="headerlink" title="实现一种或多种负载均衡算法"></a>实现一种或多种负载均衡算法</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要答辩, 收集了部分来自各方的实战面试内容, 便于巩固.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有不当之处，请予指正 🙏.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://muzig.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="golang" scheme="http://muzig.github.io/tags/golang/"/>
    
    <category term="interview" scheme="http://muzig.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Golang Escape Analysis</title>
    <link href="http://muzig.github.io/2020/12/27/golang-escape-analysis/"/>
    <id>http://muzig.github.io/2020/12/27/golang-escape-analysis/</id>
    <published>2020-12-27T14:42:27.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码.</p><a id="more"></a><ul><li><a href="#%E5%85%B3%E4%BA%8E%E5%A0%86%E6%A0%88">关于堆栈</a></li><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F">函数变量</a></li><li><a href="#%E9%97%B4%E6%8E%A5%E8%B5%8B%E5%80%BC">间接赋值</a></li><li><a href="#interface">interface</a></li><li><a href="#channel">channel</a></li><li><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><p>Go 语言较之 C 语言一个很大的优势就是自带 GC 功能，可 GC 并不是没有代价的。写 C 语言的时候，在一个函数内声明的变量，在函数退出后会自动释放掉，因为这些变量分配在栈上。如果你想要变量的数据能在函数退出后还能访问，就需要调用 malloc 方法在堆上申请内存，如果程序不再需要这块内存了，再调用 free 方法释放掉。Go 语言不需要你主动调用 malloc 来分配堆空间，编译器会自动分析，找出需要 malloc 的变量，使用堆内存。编译器的这个分析过程就叫做逃逸分析。</p><h2 id="关于堆栈"><a href="#关于堆栈" class="headerlink" title="关于堆栈"></a>关于堆栈</h2><p>区别如下:</p><ol><li>申请方式的不同。栈由系统自动分配，而堆是人为申请开辟;</li><li>申请大小的不同。栈获得的空间较小，而堆获得的空间较大;</li><li>申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢;</li><li>存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;</li><li>底层不同。栈是连续的空间，而堆是不连续的空间。</li></ol><p>详细细节链接:</p><ul><li><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Language Mechanics On Stacks And Pointers</a></li><li><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">Language Mechanics On Escape Analysis</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stack</span><span class="params">()</span> <span class="title">int</span></span> &#123; </span><br><span class="line">    <span class="comment">// 变量 i 会在栈上分配</span></span><br><span class="line">     i := <span class="number">10</span></span><br><span class="line">     <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heap</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 变量 j 会在堆上分配</span></span><br><span class="line">    j := <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> &amp;j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析汇编指令如下:</span></span><br><span class="line">go build --gcflags <span class="string">&#x27;-l&#x27;</span> test.go</span><br><span class="line">go tool objdump ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>!!! 不要以为使用了堆内存就一定会导致性能低下，使用栈内存会带来性能优势。因为实际项目中，系统的性能瓶颈一般都不会出现在内存分配上。千万不要盲目优化，找到系统瓶颈，用数据驱动优化。</p></blockquote><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>需要使用堆空间则逃逸，这没什么可争议的。但编译器有时会将不需要使用堆空间的变量，也逃逸掉。这里是容易出现性能问题的大坑。网上有很多相关文章，列举了一些导致逃逸情况，其实总结起来就一句话：</p><p><strong>多级间接赋值容易导致逃逸。</strong></p><p>Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type(指针)。</p><p>记住公式 Data.Field = Value，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递。</p><h3 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h3><blockquote><p>若函数是变量, 且参数也是引用类型, 则会发生逃逸</p></blockquote><h3 id="间接赋值"><a href="#间接赋值" class="headerlink" title="间接赋值"></a>间接赋值</h3><blockquote><p>良好的写法是, 在返回的时候再引用地址</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    data  <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    slice []<span class="keyword">int</span></span><br><span class="line">    ch    <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    inf   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    p     *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := Data&#123;&#125;</span><br><span class="line">    d1.data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)   <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)   <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.inf = <span class="number">3</span>                  <span class="comment">// GOOD: does not escape</span></span><br><span class="line">    d1.p = <span class="built_in">new</span>(<span class="keyword">int</span>)             <span class="comment">//  GOOD: does not escape</span></span><br><span class="line"></span><br><span class="line">    d2 := <span class="built_in">new</span>(Data)             <span class="comment">// d2 是指针变量， 下面为该指针变量中的指针成员赋值</span></span><br><span class="line">    d2.data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">// BAD: escape to heap</span></span><br><span class="line">    d2.slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)   <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">    d2.ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)   <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">    d2.inf = <span class="number">3</span>                  <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">    d2.p = <span class="built_in">new</span>(<span class="keyword">int</span>)             <span class="comment">// BAD:  escape to heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>只要使用了 Interface 类型(不是 interafce{})，那么赋值给它的变量一定会逃逸。因为 interfaceVariable.Method() 先是间接的定位到它的实际值，再调用实际值的同名方法，执行时实际值作为参数传递给方法。相当于interfaceVariable.Method.this = realValue</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Iface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Dummy()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Integer)</span> <span class="title">Dummy</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        iface Iface</span><br><span class="line">        i     Integer</span><br><span class="line">    )</span><br><span class="line">    iface = i</span><br><span class="line">    iface.Dummy() <span class="comment">//  make i escape to heap</span></span><br><span class="line">    <span class="comment">// 形成 iface.Dummy.i = i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><blockquote><p>发送到 channel 的数据类型都将逃逸</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        chInteger   = <span class="built_in">make</span>(<span class="keyword">chan</span> *<span class="keyword">int</span>)</span><br><span class="line">        chMap       = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">        chSlice     = <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br><span class="line">        chInterface = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">        a, b, c, d  = <span class="number">0</span>, <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;&#125;, <span class="number">32</span></span><br><span class="line">    )</span><br><span class="line">    chInteger &lt;- &amp;a  <span class="comment">// 逃逸</span></span><br><span class="line">    chMap &lt;- b       <span class="comment">// 逃逸</span></span><br><span class="line">    chSlice &lt;- c     <span class="comment">// 逃逸</span></span><br><span class="line">    chInterface &lt;- d <span class="comment">// 逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数如 func(arg …string) 实际与 func(arg []string) 是一样的，会增加一层访问路径。这也是 fmt.Sprintf 总是会使参数逃逸的原因。</p><p>例子非常多，这里不能一一列举，我们只需要记住分析方法就好</p><p>即，2 级或更多级的访问赋值会容易导致数据逃逸。这里加上容易二字是因为随着语言的发展，相信这些问题会被慢慢解决，但现阶段，这个可以作为我们分析逃逸现象的依据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    roles []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">SetRoles</span><span class="params">(roles []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.roles = roles</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetRoles</span><span class="params">(u User, roles []<span class="keyword">string</span>)</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    u.roles = roles</span><br><span class="line">    <span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    A []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">Set</span><span class="params">(a []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.A = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(user User, a []<span class="keyword">string</span>)</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    user.A = a</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUser</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="comment">// BenchmarkUser-4      39182143            29.0 ns/op</span></span><br><span class="line">    <span class="comment">//u := new(User)</span></span><br><span class="line">    <span class="comment">//for i := 0; i &lt; b.N; i++ &#123;</span></span><br><span class="line">    <span class="comment">//  u.Set([]string&#123;&quot;a&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BenchmarkUser-4   1000000000         0.585 ns/op</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _ = SetUser(User&#123;&#125;, []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>大多数情况下，性能优化都会为程序带来一定的复杂度。<strong>建议实际项目中还是怎么方便怎么写，功能完成后通过性能分析找到瓶颈所在，再对局部进行优化。</strong></li><li>多级间接赋值会导致 Go 编译器出现不必要的逃逸，在一些情况下可能我们只需要修改一下数据结构就会使性能有大幅提升。这也是很多人不推荐在 Go 中使用指针的原因，因为它会增加一级访问路径，而 map, slice, interface{}等类型是不可避免要用到的，为了减少不必要的逃逸，只能拿指针开刀了。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/518466b4ee96">达菲格-Go 语言内存管理（三）：逃逸分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码.&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://muzig.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="golang" scheme="http://muzig.github.io/tags/golang/"/>
    
    <category term="escape-analysis" scheme="http://muzig.github.io/tags/escape-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Golang GC</title>
    <link href="http://muzig.github.io/2020/12/26/golang-GC/"/>
    <id>http://muzig.github.io/2020/12/26/golang-GC/</id>
    <published>2020-12-26T23:32:41.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<ul><li>标记清除</li><li>并行标记清除</li><li>三色标记法</li><li>Hybrid Write Barrier</li></ul><a id="more"></a><ul><li><a href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4--%E5%B9%B6%E8%A1%8C%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4">标记清除 &amp; 并行标记清除</a></li><li><a href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95">三色标记法</a></li><li><a href="#hybrid-write-barrier-%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C">Hybrid Write Barrier (混合写屏障)</a></li><li><a href="#%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91-gc">何时触发 GC</a></li><li><a href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96">其他优化</a></li><li><a href="#%E5%B1%95%E6%9C%9B">展望</a></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><h2 id="标记清除-amp-并行标记清除"><a href="#标记清除-amp-并行标记清除" class="headerlink" title="标记清除 &amp; 并行标记清除"></a>标记清除 &amp; 并行标记清除</h2><p>GC 开始之后, 启动 STW 然后从 root 开始,  root 区值当前所有 goroutine 的栈和全局数据区的变量(主要是这 2 个地方), 将能被触及的 object 标记, 剩下的就是可回收的; 最后再清理放回 mcache 中, 以备后续使用.</p><p>并行标记清除, 实际上是清理过程不需要 STW, 减少了 STW 的时间.</p><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p><img src="/../img/gc_algorithm.png" alt="gc-algorithm"></p><ol><li>正常情况下，写操作就是正常的赋值。</li><li>GC 开始，开启写屏障等准备工作。开启写屏障等准备工作需要短暂的 STW。</li><li>Stack scan 阶段，从全局空间和 goroutine 栈空间上收集变量。</li><li>Mark 阶段，执行上述的三色标记法，直到没有灰色对象。</li><li>Mark termination 阶段，开启 STW，回头重新扫描 root 区域新变量，对他们进行标记。</li><li>Sweep 阶段，关闭 STW 和 写屏障，对白色对象进行清除。</li></ol><h2 id="Hybrid-Write-Barrier-混合写屏障"><a href="#Hybrid-Write-Barrier-混合写屏障" class="headerlink" title="Hybrid Write Barrier (混合写屏障)"></a>Hybrid Write Barrier (混合写屏障)</h2><p>Go 在 1.8 版本引入了混合写屏障，其会在赋值前，对旧数据置灰，再视情况对新值进行置灰。</p><p><img src="/../img/gc-hyber.png" alt="gc-hybrid"></p><h2 id="何时触发-GC"><a href="#何时触发-GC" class="headerlink" title="何时触发 GC"></a>何时触发 GC</h2><ul><li>容量触发 - 达到设置的阈值触发 GC, 默认为100(即内存增长100%即触发一次), 可以通过环境变量 GOGC 或者 debug.SetGCPercent()</li><li>时间触发 - 每隔 2 分钟, 触发一次 GC</li><li>手动触发 - runtime.GC()</li></ul><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul><li>只会占用 25% 的 cpu 算力处理 GC 逻辑, 保证减少对用户的影响. 若下一轮 GC 触发, 会等待上一轮执行完毕</li><li>对于 tiny 对象, 直接标记黑色, 没有灰色阶段, 因为不存在引用对象</li><li>采用对象池的方式, 减少 GC 的压力, 但实际上也会存在标记的压力; 如果可以放在永久标记, 就可以减少标记压力</li><li>直接申请大内存(大于32k), 对 GC 来说是一个 largespan; 需要自行代码管理</li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><ol><li>引入分代机制, 像 JVM 那样内存分为 一级/二级/永久, 不同级别, 采用不同的计算资源</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>减少层级数 - 嵌套层级越多, 对于 GC 的压力越大; 如: chan map[string][]*string</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/">Golang GC核心要点和度量方法</a></li><li><a href="https://wudaijun.com/2017/12/gc-study/">常见GC算法及Golang GC</a></li><li><a href="https://www.jianshu.com/p/0083a90a8f7e">达菲格-Go 语言内存管理（四）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;标记清除&lt;/li&gt;
&lt;li&gt;并行标记清除&lt;/li&gt;
&lt;li&gt;三色标记法&lt;/li&gt;
&lt;li&gt;Hybrid Write Barrier&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="后端" scheme="http://muzig.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="golang" scheme="http://muzig.github.io/tags/golang/"/>
    
    <category term="gc" scheme="http://muzig.github.io/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Golang Scheduling</title>
    <link href="http://muzig.github.io/2020/12/26/golang-scheduling/"/>
    <id>http://muzig.github.io/2020/12/26/golang-scheduling/</id>
    <published>2020-12-26T15:40:47.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.</p><a id="more"></a><ul><li><a href="#gpm-%E6%A8%A1%E5%9E%8B">GPM 模型</a></li><li><a href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B">调度流程</a></li><li><a href="#%E7%94%A8%E6%88%B7%E6%96%B9%E5%BC%8F%E9%98%BB%E5%A1%9E%E5%94%A4%E9%86%92">用户方式阻塞/唤醒</a></li><li><a href="#syscall">syscall</a></li><li><a href="#sysmon">sysmon</a></li><li><a href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6">抢占式调度</a></li><li><a href="#netpoll">netpoll</a></li><li><a href="#g-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B">g 的创建流程</a></li><li><a href="#g-%E7%9A%84%E6%9A%82%E5%81%9C%E6%96%B9%E5%BC%8F">g 的暂停方式</a></li><li><a href="#go-%E8%B0%83%E5%BA%A6%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F">Go 调度查看方式</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><p>文件位置: src/runtime/runtime2.go</p><ul><li>g(goroutine): 对应到 g 结构体, 保存 goroutin 需要的堆栈信息</li><li>p(process):   相当于 g 的驱动, 只有绑定在 local runq 下, 才能被调度</li><li>m(machine):   OS 线程抽象, 真正的驱动力, 和某个 p 绑定, 然后 p 从 local runq 中依次取出 g 用来执行</li></ul><p><img src="/../img/go-shechduling.png" alt="go-sheduling"></p><p>补充:</p><ol><li>最早 go1.1 仅仅是 GM 模式, 后续 Dmitry Vyukov 为了解决<strong>并发伸缩性</strong>问题, 引入 p 的概念 <a href="https://github.com/muzig/muzig.github.io/blob/main/source/pdf/Scalable%20Go%20Scheduler%20Design%20Doc.pdf">提案文档</a></li><li>g 的数量受限于 GOMAXPROCS, 即超线程数量, 一般 intel cpu 具有超线程技术, 双核四线程, 即数量为4</li><li>m 的个数是不定的，由Go Runtime调整，默认最大限制为10000个</li></ol><h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><ol><li>m 与 p 绑定, m 从 p 的 local runq 中取出并切换到 g 的堆栈执行<ol><li>若 local runq 存在 g, 则执行(无锁)</li><li>若不存在, 从 global runq 取出 g 执行(有锁)</li><li>若依然不存在, 则从其他 p “窃取” g 执行</li></ol></li><li>若没有 g 可以执行, 则 m 与 p 解绑, 进入休眠模式(idle)</li></ol><h2 id="用户方式阻塞-唤醒"><a href="#用户方式阻塞-唤醒" class="headerlink" title="用户方式阻塞/唤醒"></a>用户方式阻塞/唤醒</h2><p>阻塞:</p><p>当 g 被 channel 卡住, m 会跳过执行下一个, 并将 g 放置在 waitq 里面</p><p>唤醒:</p><p>当 g 执行的时候, 通过 channel 向另一个 g2 投递消息, 则 g2 将直接”插队”, 放下一个执行</p><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>若 g 被阻塞在一个系统调用上, 则 p 将于 m 解绑, 寻找 idle 状态的 m 再此绑定; 若没有 idle 状态的 m, 则创建一个新的 m.</p><p>系统调用结束, g 会重新寻找 idle 状态的 p, 并恢复执行, 若没有则放到 globl runq 中.</p><p>系统被调度的两个关键点:</p><ol><li>runtime/syscall包中, 系统调用分为 syscall &amp; rawsyscall, 区别在于前者会记录保存和恢复所需状态, 这样可以安全的解绑; 某些系统调用可以预先评估是会长时间阻塞, 则会发起之前, 直接 p &amp; m 解绑(handoffp)</li><li>sysmon 负责检查系统调用时间, 决定是否需要 handoffp</li></ol><h2 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h2><p>sysmon 是一个由 runtime 启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次.</p><p>流程如下:</p><ol><li>释放闲置超过5分钟的span物理内存；</li><li>如果超过2分钟没有垃圾回收，强制执行；</li><li>将长时间未处理的netpoll结果添加到任务队列；</li><li>向长时间运行的G任务发出抢占调度；</li><li>收回因syscall长时间阻塞的P；</li></ol><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p>当某个 g 执行超过10ms, 则 sysmon 将发起抢占式请求, 会给 g 打上标签; 当 g 执行函数时(更确切说，在通过newstack分配函数栈时), 将被 runtime.Goched 的方式暂停, 放置在 global runq 中</p><h2 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h2><p>除了之前提到的, local runq, runqnext, global runq, 还存在对网络 I/O 进行优化的 netpoll, 本地避免网络I/O的时候陷入系统调用, 不阻塞 M (而是阻塞 G ), 从而不会导致大量的 M 被创建</p><h2 id="g-的创建流程"><a href="#g-的创建流程" class="headerlink" title="g 的创建流程"></a>g 的创建流程</h2><ol><li>当 go func(){} 执行的时候, 会尝试从池子中复用, 没有则创建</li><li>尝试”插队”, 放置到当前 p 的 runnext 里面</li><li>否则放置到 local runq 中(无锁)</li><li>否则放置到 global runq 中(有锁)</li></ol><h2 id="g-的暂停方式"><a href="#g-的暂停方式" class="headerlink" title="g 的暂停方式"></a>g 的暂停方式</h2><ul><li>常规方式  - 将 g 阻塞, 放到 global runq 中, 等待被获取执行</li><li>等待方式  - 将 g 阻塞, 放到 waitq 中, 等待被其他 g 唤醒</li><li>自旋方式  - gpm 都不调度, 直到被唤醒</li><li>退出方式  - 立即终止 g 任务, 确保 defer 正常执行</li><li>process 方式 - 放飞 p, 阻塞 g m, p 可以跟其他 m 绑定</li></ul><h2 id="Go-调度查看方式"><a href="#Go-调度查看方式" class="headerlink" title="Go 调度查看方式"></a>Go 调度查看方式</h2><ul><li><a href="https://wudaijun.com/2018/01/go-scheduler/">Go 调度模型</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从调度模型, 到 gpm 的探讨, 讲到了阻塞和唤醒的流程, 以及如何抢占, 延伸到 sysmon 服务的特点; 最后补充了 netpoll 优化和 g 的创建流程和状态介绍.<br>回过头来, 我们再看看, 学习调度的目的其实实际需求来讲, 就是编写更加高效的并发程序, 明白了流程, 还需要实战, 后续再更新代码实战的情况.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wudaijun.com/2018/01/go-scheduler/">Go 调度模型</a></li><li><a href="https://wudaijun.com/2018/11/scheduler-blabla/">再谈调度</a></li><li><a href="https://www.jianshu.com/p/db0aea4d60ed">达菲格-Go 语言调度（一）: 系统调度</a></li><li><a href="https://www.jianshu.com/p/cb6881a2661d">达菲格-Go 语言调度（二）: goroutine 调度器</a></li><li><a href="https://www.jianshu.com/p/ef654413f2c1">达菲格-Go 语言调度（三）: 并发</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://muzig.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="golang" scheme="http://muzig.github.io/tags/golang/"/>
    
    <category term="scheduling" scheme="http://muzig.github.io/tags/scheduling/"/>
    
  </entry>
  
  <entry>
    <title>Shell 笔记</title>
    <link href="http://muzig.github.io/2020/12/19/shell-note/"/>
    <id>http://muzig.github.io/2020/12/19/shell-note/</id>
    <published>2020-12-19T15:22:53.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务.</p><p>科技改变生活, 脚本释放双手.</p><a id="more"></a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">基础语法</a><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li></ul></li><li><a href="#%E4%BC%A0%E5%8F%82">传参</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a><ul><li><a href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">算数运算符</a></li><li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li><li><a href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6">布尔运算符</a></li><li><a href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97%E7%AC%A6">字符串运算符</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%BF%90%E7%AE%97%E7%AC%A6">文件测试运算符</a></li></ul></li><li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a><ul><li><a href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6">条件控制</a></li><li><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">循环控制</a></li></ul></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a></li><li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a><ul><li><a href="#devnull-%E6%96%87%E4%BB%B6">/dev/null 文件</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8">文件引用</a></li><li><a href="#oh-my-zsh-%E6%BA%90%E7%A0%81">oh-my-zsh 源码</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 赋值等号两边不能添加空格</span></span><br><span class="line">name=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;name&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常量</span></span><br><span class="line">name=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">readonly</span> name</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line">name=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">unset</span> name</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>单引号<ul><li>原样输出, 不支持变量引用</li></ul></li><li>双引号<ul><li>支持变量引用</li><li>支持转义字符</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取字符串长度</span></span><br><span class="line">name=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取字符串</span></span><br><span class="line">name=<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;name:1:3&#125;</span> <span class="comment"># 输出ell</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字符串</span></span><br><span class="line">string=<span class="string">&quot;runoob is a great site&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">&quot;<span class="variable">$string</span>&quot;</span> io`  <span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 value2 ... valuen)</span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">v1=<span class="variable">$&#123;array_name[0]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">EOF</span>符号可以换成其他, 比如`<span class="string">&#x27;之类的</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><ul><li>$0: 文件名</li><li>$1: 命令行执行的第一个参数</li><li>$2: 命令行执行的第二个参数</li></ul><p><img src="/../img/shell-arg.png" alt="shell-arg"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><img src="/../img/shell-algorithm.png" alt="算数"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/../img/shell-logic.png" alt="逻辑"></p><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p><img src="/../img/shell-bool.png" alt="布尔"></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="/../img/shell-relation.png" alt="关系"></p><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p><img src="/../img/shell-str.png" alt="字符串"></p><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p><img src="/../img/shell-file-test.png" alt="文件测试"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>关键字: break continue</p><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多行</span></span><br><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行</span></span><br><span class="line"><span class="keyword">if</span> [ $(ps -ef | grep -c <span class="string">&quot;ssh&quot;</span>) -gt 1 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;true&quot;</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多行</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN; <span class="keyword">do</span> command1; command2… <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 条件循环</span></span><br><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件循环</span></span><br><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">demoFun</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这是我的第一个 shell 函数!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----函数开始执行-----&quot;</span></span><br><span class="line">demoFun</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----函数执行完毕-----&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">-----函数开始执行-----</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">-----函数执行完毕-----</span><br></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><img src="/../img/shell-redirect.png" alt="shell-redirect"></p><h3 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><h2 id="文件引用"><a href="#文件引用" class="headerlink" title="文件引用"></a>文件引用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://muzig.github.io&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 . 号来引用src.sh 文件</span></span><br><span class="line">. ./src.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用以下包含文件代码</span></span><br><span class="line"><span class="built_in">source</span> ./src.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Blog：<span class="variable">$url</span>&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">Blog: http://muzig.github.io</span><br></pre></td></tr></table></figure><h2 id="oh-my-zsh-源码"><a href="#oh-my-zsh-源码" class="headerlink" title="oh-my-zsh 源码"></a>oh-my-zsh 源码</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If ZSH is not defined, use the current script&#x27;s directory.</span></span><br><span class="line">[[ -z <span class="string">&quot;<span class="variable">$ZSH</span>&quot;</span> ]] &amp;&amp; <span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$&#123;<span class="variable">$&#123;(%):-%x&#125;</span>:a:h&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set ZSH_CACHE_DIR to the path where cache files should be created</span></span><br><span class="line"><span class="comment"># or else we will use the default cache/</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$ZSH_CACHE_DIR</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ZSH_CACHE_DIR=<span class="string">&quot;<span class="variable">$ZSH</span>/cache&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for updates on initial load...</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$DISABLE_AUTO_UPDATE</span>&quot;</span> != <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$ZSH</span>/tools/check_for_upgrade.sh</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initializes Oh My Zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add a function path</span></span><br><span class="line">fpath=(<span class="variable">$ZSH</span>/<span class="built_in">functions</span> <span class="variable">$ZSH</span>/completions <span class="variable">$fpath</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load all stock functions (from $fpath files) called below.</span></span><br><span class="line"><span class="built_in">autoload</span> -U compaudit compinit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set ZSH_CUSTOM to the path where your custom config files</span></span><br><span class="line"><span class="comment"># and plugins exists, or else we will use the default custom/</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    ZSH_CUSTOM=<span class="string">&quot;<span class="variable">$ZSH</span>/custom&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">is_plugin</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> base_dir=<span class="variable">$1</span></span><br><span class="line">  <span class="built_in">local</span> name=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">builtin</span> <span class="built_in">test</span> -f <span class="variable">$base_dir</span>/plugins/<span class="variable">$name</span>/<span class="variable">$name</span>.plugin.zsh \</span><br><span class="line">    || <span class="built_in">builtin</span> <span class="built_in">test</span> -f <span class="variable">$base_dir</span>/plugins/<span class="variable">$name</span>/_<span class="variable">$name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add all defined plugins to fpath. This must be done</span></span><br><span class="line"><span class="comment"># before running compinit.</span></span><br><span class="line"><span class="keyword">for</span> plugin (<span class="variable">$plugins</span>); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> is_plugin <span class="variable">$ZSH_CUSTOM</span> <span class="variable">$plugin</span>; <span class="keyword">then</span></span><br><span class="line">    fpath=(<span class="variable">$ZSH_CUSTOM</span>/plugins/<span class="variable">$plugin</span> <span class="variable">$fpath</span>)</span><br><span class="line">  <span class="keyword">elif</span> is_plugin <span class="variable">$ZSH</span> <span class="variable">$plugin</span>; <span class="keyword">then</span></span><br><span class="line">    fpath=(<span class="variable">$ZSH</span>/plugins/<span class="variable">$plugin</span> <span class="variable">$fpath</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[oh-my-zsh] plugin &#x27;<span class="variable">$plugin</span>&#x27; not found&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Figure out the SHORT hostname</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$OSTYPE</span>&quot;</span> = darwin* ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># macOS&#x27;s $HOST changes with dhcp, etc. Use ComputerName if possible.</span></span><br><span class="line">  SHORT_HOST=$(scutil --get ComputerName 2&gt;/dev/null) || SHORT_HOST=<span class="variable">$&#123;HOST/.*/&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  SHORT_HOST=<span class="variable">$&#123;HOST/.*/&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the location of the current completion dump file.</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  ZSH_COMPDUMP=<span class="string">&quot;<span class="variable">$&#123;ZDOTDIR:-<span class="variable">$&#123;HOME&#125;</span>&#125;</span>/.zcompdump-<span class="variable">$&#123;SHORT_HOST&#125;</span>-<span class="variable">$&#123;ZSH_VERSION&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct zcompdump OMZ metadata</span></span><br><span class="line">zcompdump_revision=<span class="string">&quot;#omz revision: <span class="subst">$(builtin cd -q <span class="string">&quot;<span class="variable">$ZSH</span>&quot;</span>; git rev-parse HEAD 2&gt;/dev/null)</span>&quot;</span></span><br><span class="line">zcompdump_fpath=<span class="string">&quot;#omz fpath: <span class="variable">$fpath</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete the zcompdump file if OMZ zcompdump metadata changed</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span> grep -q -Fx <span class="string">&quot;<span class="variable">$zcompdump_revision</span>&quot;</span> <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> 2&gt;/dev/null \</span><br><span class="line">   || ! <span class="built_in">command</span> grep -q -Fx <span class="string">&quot;<span class="variable">$zcompdump_fpath</span>&quot;</span> <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> rm -f <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span></span><br><span class="line">  zcompdump_refresh=1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$ZSH_DISABLE_COMPFIX</span> != <span class="literal">true</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$ZSH</span>/lib/compfix.zsh</span><br><span class="line">  <span class="comment"># If completion insecurities exist, warn the user</span></span><br><span class="line">  handle_completion_insecurities</span><br><span class="line">  <span class="comment"># Load only from secure directories</span></span><br><span class="line">  compinit -i -C -d <span class="string">&quot;<span class="variable">$&#123;ZSH_COMPDUMP&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># If the user wants it, load from all found directories</span></span><br><span class="line">  compinit -u -C -d <span class="string">&quot;<span class="variable">$&#123;ZSH_COMPDUMP&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Append zcompdump metadata if missing</span></span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$zcompdump_refresh</span> )); <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Use `tee` in case the $ZSH_COMPDUMP filename is invalid, to silence the error</span></span><br><span class="line">  <span class="comment"># See https://github.com/ohmyzsh/ohmyzsh/commit/dd1a7269#commitcomment-39003489</span></span><br><span class="line">  tee -a <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> &amp;&gt;/dev/null &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$zcompdump_revision</span></span><br><span class="line"><span class="string">$zcompdump_fpath</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> zcompdump_revision zcompdump_fpath zcompdump_refresh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load all of the config files in ~/oh-my-zsh that end in .zsh</span></span><br><span class="line"><span class="comment"># TIP: Add files you don&#x27;t want in git to .gitignore</span></span><br><span class="line"><span class="keyword">for</span> config_file (<span class="variable">$ZSH</span>/lib/*.zsh); <span class="keyword">do</span></span><br><span class="line">  custom_config_file=<span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM&#125;</span>/lib/<span class="variable">$&#123;config_file:t&#125;</span>&quot;</span></span><br><span class="line">  [ -f <span class="string">&quot;<span class="variable">$&#123;custom_config_file&#125;</span>&quot;</span> ] &amp;&amp; config_file=<span class="variable">$&#123;custom_config_file&#125;</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$config_file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load all of the plugins that were defined in ~/.zshrc</span></span><br><span class="line"><span class="keyword">for</span> plugin (<span class="variable">$plugins</span>); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="variable">$ZSH_CUSTOM</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh</span><br><span class="line">  <span class="keyword">elif</span> [ -f <span class="variable">$ZSH</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="variable">$ZSH</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load all of your custom configurations from custom/</span></span><br><span class="line"><span class="keyword">for</span> config_file (<span class="variable">$ZSH_CUSTOM</span>/*.zsh(N)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$config_file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">unset</span> config_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the theme</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;<span class="variable">$ZSH_THEME</span>&quot;</span> = <span class="string">&quot;&quot;</span>  ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> [ -f <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/themes/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/themes/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$ZSH</span>/themes/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/wangdoc/bash-tutorial">阮一峰的《Bash 脚本教程》</a></li><li><a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程 | 菜鸟教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务.&lt;/p&gt;
&lt;p&gt;科技改变生活, 脚本释放双手.&lt;/p&gt;</summary>
    
    
    
    <category term="脚本" scheme="http://muzig.github.io/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="shell" scheme="http://muzig.github.io/tags/shell/"/>
    
    <category term="note" scheme="http://muzig.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Goland 破解教程</title>
    <link href="http://muzig.github.io/2020/12/05/goland-cracking/"/>
    <id>http://muzig.github.io/2020/12/05/goland-cracking/</id>
    <published>2020-12-05T12:58:28.000Z</published>
    <updated>2021-01-30T06:00:00.949Z</updated>
    
    <content type="html"><![CDATA[<p>破解方式: 循环重置试用时间.</p><a id="more"></a><ul><li><a href="#%E6%95%99%E7%A8%8B">教程</a></li><li><a href="#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5">友情链接</a></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>步骤:</p><ol><li>打开 goland, 选择试用, 进入IDE界面</li><li>Menu - Goland - Perference - Plugins</li><li>点击像齿轮的图标(如下图)</li><li>Manager Plugin Repos</li><li>添加此链接: <code>https://plugins.zhile.io</code>, 等待刷新完成</li><li>搜索插件 <code>IDE Eval reset</code>, 插件描述有说明和使用方法</li><li>下载安装重启 IDE</li></ol><p><img src="/../img/Snipaste_2020-12-05_13-03-28.png" alt="齿轮"></p><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><ul><li><a href="https://zhile.io/">破解大佬博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;破解方式: 循环重置试用时间.&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://muzig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="crack" scheme="http://muzig.github.io/tags/crack/"/>
    
    <category term="goland" scheme="http://muzig.github.io/tags/goland/"/>
    
  </entry>
  
</feed>
