{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://muzig.github.io"},"pages":[{"title":"Docker 笔记","date":"2021-01-31T19:54:25.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/docker-note.html","permalink":"http://muzig.github.io/drafts/docker-note.html","excerpt":"掌握其在微服务开发中的运用.","text":"掌握其在微服务开发中的运用. TODO 容器使用 仓库运用 私有仓库 高级仓库配置 数据管理 数据卷 挂载目录 挂载单个文件 TODO基本: 基本概念 镜像使用 容器使用 仓库运用 进阶: 数据管理 网络配置 Docker Buildx Docker Compose Swarm Mode 安全 底层实现 实战: ETCD项目 CoreOS项目 k8s 容器与云计算 CI/CD 最佳实践 容器使用12345678docker rundocker stopdocker logsdocker rmdocker prune # 清理所有停掉的containerdocker attachdocker exec -it &lt;id&gt; bash 123456docker export &lt;id&gt; &gt; ubuntu.tarcat ubuntu.tar | docker import - test/ubuntu:v1.0# 区别在于是否丢弃历史记录以及元数据信息docker importdocker load 仓库运用 仓库(Repository) 注册服务器(Registry) 12345678910docker logindocker logoutdocker searchdocker pull# 推送imagedocker tag ubuntu:18.04 username/ubuntu:18.04docker push username/ubuntu:18.04docker search username 私有仓库工具: docker-registry 高级仓库配置工具: Docker Compose 拥有权限认证, TLS的私有仓库 略… 数据管理 数据卷(Volumes) - 可供一个或多个容器使用的特殊目录; 绕过UFS 挂载主机目录(Bind Mounts) 数据卷1234567docker volume create my-voldocker volume rm my-voldocker volume lsdocker volume prunedocker volume inspect my-vol 1234567docker run -d -P \\--name web \\--mount source=myvol,target=/webapp \\training/webapp \\python app.pydocker inspect web 挂载目录12345docker run -d -P \\--name web \\--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \\ # source代表宿主机; target代表容器位置; readonly代表容器位置只读training/webapp \\python app.py 挂载单个文件12345# 这样就可以记录容器的命令使用情况docker run --rm -it \\--mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \\ubuntu:18.04 \\bash","raw":null,"content":null},{"title":"Git 问题收集","date":"2021-02-17T11:06:42.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/git.html","permalink":"http://muzig.github.io/drafts/git.html","excerpt":"收集一些不常见关于 git 的一些问题, 以及处理办法.","text":"收集一些不常见关于 git 的一些问题, 以及处理办法. push clone –depth push报错信息: 切换多个github账号的时候, 会有权限冲突. 12remote: Permission to &lt;user-a&gt;.git denied to &lt;user-b&gt;fatal: unable to access &#x27;https://github.com/ xxxxx.git/&#x27;: &gt; The requested URL returned error: 403 解决方案: 12git config credential.username &lt;user-a&gt;git push origin main clone–depth 报错信息: 1! [remote rejected] main -&gt; main (shallow update not allowed) 原因: 最初克隆仓库采用的 –depth 参数, 然后修改 remote 重新推送新仓库. 1234567# 浅克隆git clone --depth=1 &lt;仓库地址&gt;# 修改remotegit remote remove origingit remote add origin &lt;新仓库地址&gt;# 推送git push -u origin &lt;xxx&gt; # 这个步骤就会发生报错 解决办法: 简单粗暴: 1234567# 清理记录rm -rf .git# 重新构建仓库git initgit remote add origin &lt;新仓库地址&gt;git push -u origin &lt;xxx&gt;","raw":null,"content":null},{"title":"Goland 破解教程","date":"2020-12-05T12:58:28.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/goland-cracking.html","permalink":"http://muzig.github.io/drafts/goland-cracking.html","excerpt":"破解方式: 循环重置试用时间.","text":"破解方式: 循环重置试用时间. 教程 友情链接 教程步骤: 打开 goland, 选择试用, 进入IDE界面 Menu - Goland - Perference - Plugins 点击像齿轮的图标(如下图) Manager Plugin Repos 添加此链接: https://plugins.zhile.io, 等待刷新完成 搜索插件 IDE Eval reset, 插件描述有说明和使用方法 下载安装重启 IDE 友情链接 破解大佬博客","raw":null,"content":null},{"title":"Golang GC","date":"2020-12-26T23:32:41.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/golang-GC.html","permalink":"http://muzig.github.io/drafts/golang-GC.html","excerpt":"\n标记清除\n并行标记清除\n三色标记法\nHybrid Write Barrier\n","text":"标记清除 并行标记清除 三色标记法 Hybrid Write Barrier 标记清除 &amp; 并行标记清除 三色标记法 Hybrid Write Barrier (混合写屏障) 何时触发 GC 其他优化 展望 结论 参考链接 标记清除 &amp; 并行标记清除GC 开始之后, 启动 STW 然后从 root 开始, root 区值当前所有 goroutine 的栈和全局数据区的变量(主要是这 2 个地方), 将能被触及的 object 标记, 剩下的就是可回收的; 最后再清理放回 mcache 中, 以备后续使用. 并行标记清除, 实际上是清理过程不需要 STW, 减少了 STW 的时间. 三色标记法 正常情况下，写操作就是正常的赋值。 GC 开始，开启写屏障等准备工作。开启写屏障等准备工作需要短暂的 STW。 Stack scan 阶段，从全局空间和 goroutine 栈空间上收集变量。 Mark 阶段，执行上述的三色标记法，直到没有灰色对象。 Mark termination 阶段，开启 STW，回头重新扫描 root 区域新变量，对他们进行标记。 Sweep 阶段，关闭 STW 和 写屏障，对白色对象进行清除。 Hybrid Write Barrier (混合写屏障)Go 在 1.8 版本引入了混合写屏障，其会在赋值前，对旧数据置灰，再视情况对新值进行置灰。 何时触发 GC 容量触发 - 达到设置的阈值触发 GC, 默认为100(即内存增长100%即触发一次), 可以通过环境变量 GOGC 或者 debug.SetGCPercent() 时间触发 - 每隔 2 分钟, 触发一次 GC 手动触发 - runtime.GC() 其他优化 只会占用 25% 的 cpu 算力处理 GC 逻辑, 保证减少对用户的影响. 若下一轮 GC 触发, 会等待上一轮执行完毕 对于 tiny 对象, 直接标记黑色, 没有灰色阶段, 因为不存在引用对象 采用对象池的方式, 减少 GC 的压力, 但实际上也会存在标记的压力; 如果可以放在永久标记, 就可以减少标记压力 直接申请大内存(大于32k), 对 GC 来说是一个 largespan; 需要自行代码管理 展望 引入分代机制, 像 JVM 那样内存分为 一级/二级/永久, 不同级别, 采用不同的计算资源 结论 减少层级数 - 嵌套层级越多, 对于 GC 的压力越大; 如: chan map[string][]*string 参考链接 Golang GC核心要点和度量方法 常见GC算法及Golang GC 达菲格-Go 语言内存管理（四）","raw":null,"content":null},{"title":"Golang Escape Analysis","date":"2020-12-27T14:42:27.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/golang-escape-analysis.html","permalink":"http://muzig.github.io/drafts/golang-escape-analysis.html","excerpt":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码.","text":"了解 Golang 语言的逃逸机制, 有助于在编写代码的时候绕开逃逸分析的缺陷, 从而编写更加高效的代码. 关于堆栈 逃逸分析 函数变量 间接赋值 interface channel 可变参数 总结 参考链接 Go 语言较之 C 语言一个很大的优势就是自带 GC 功能，可 GC 并不是没有代价的。写 C 语言的时候，在一个函数内声明的变量，在函数退出后会自动释放掉，因为这些变量分配在栈上。如果你想要变量的数据能在函数退出后还能访问，就需要调用 malloc 方法在堆上申请内存，如果程序不再需要这块内存了，再调用 free 方法释放掉。Go 语言不需要你主动调用 malloc 来分配堆空间，编译器会自动分析，找出需要 malloc 的变量，使用堆内存。编译器的这个分析过程就叫做逃逸分析。 关于堆栈区别如下: 申请方式的不同。栈由系统自动分配，而堆是人为申请开辟; 申请大小的不同。栈获得的空间较小，而堆获得的空间较大; 申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢; 存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排; 底层不同。栈是连续的空间，而堆是不连续的空间。 详细细节链接: Language Mechanics On Stacks And Pointers Language Mechanics On Escape Analysis 12345678910func stack() int &#123; // 变量 i 会在栈上分配 i := 10 return i&#125;func heap() *int &#123; // 变量 j 会在堆上分配 j := 10 return &amp;j&#125; 123# 分析汇编指令如下:go build --gcflags &#x27;-l&#x27; test.gogo tool objdump ./test !!! 不要以为使用了堆内存就一定会导致性能低下，使用栈内存会带来性能优势。因为实际项目中，系统的性能瓶颈一般都不会出现在内存分配上。千万不要盲目优化，找到系统瓶颈，用数据驱动优化。 逃逸分析需要使用堆空间则逃逸，这没什么可争议的。但编译器有时会将不需要使用堆空间的变量，也逃逸掉。这里是容易出现性能问题的大坑。网上有很多相关文章，列举了一些导致逃逸情况，其实总结起来就一句话： 多级间接赋值容易导致逃逸。 Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type(指针)。 记住公式 Data.Field = Value，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递。 函数变量 若函数是变量, 且参数也是引用类型, 则会发生逃逸 间接赋值 良好的写法是, 在返回的时候再引用地址 1234567891011121314151617181920212223type Data struct &#123; data map[int]int slice []int ch chan int inf interface&#123;&#125; p *int&#125;func main() &#123; d1 := Data&#123;&#125; d1.data = make(map[int]int) // GOOD: does not escape d1.slice = make([]int, 4) // GOOD: does not escape d1.ch = make(chan int, 4) // GOOD: does not escape d1.inf = 3 // GOOD: does not escape d1.p = new(int) // GOOD: does not escape d2 := new(Data) // d2 是指针变量， 下面为该指针变量中的指针成员赋值 d2.data = make(map[int]int) // BAD: escape to heap d2.slice = make([]int, 4) // BAD: escape to heap d2.ch = make(chan int, 4) // BAD: escape to heap d2.inf = 3 // BAD: escape to heap d2.p = new(int) // BAD: escape to heap&#125; interface只要使用了 Interface 类型(不是 interafce{})，那么赋值给它的变量一定会逃逸。因为 interfaceVariable.Method() 先是间接的定位到它的实际值，再调用实际值的同名方法，执行时实际值作为参数传递给方法。相当于interfaceVariable.Method.this = realValue 123456789101112131415type Iface interface &#123; Dummy()&#125;type Integer intfunc (i Integer) Dummy() &#123;&#125;func main() &#123; var ( iface Iface i Integer ) iface = i iface.Dummy() // make i escape to heap // 形成 iface.Dummy.i = i&#125; channel 发送到 channel 的数据类型都将逃逸 12345678910111213func test() &#123; var ( chInteger = make(chan *int) chMap = make(chan map[int]int) chSlice = make(chan []int) chInterface = make(chan interface&#123;&#125;) a, b, c, d = 0, map[int]int&#123;&#125;, []int&#123;&#125;, 32 ) chInteger &lt;- &amp;a // 逃逸 chMap &lt;- b // 逃逸 chSlice &lt;- c // 逃逸 chInterface &lt;- d // 逃逸&#125; 可变参数可变参数如 func(arg …string) 实际与 func(arg []string) 是一样的，会增加一层访问路径。这也是 fmt.Sprintf 总是会使参数逃逸的原因。 例子非常多，这里不能一一列举，我们只需要记住分析方法就好 即，2 级或更多级的访问赋值会容易导致数据逃逸。这里加上容易二字是因为随着语言的发展，相信这些问题会被慢慢解决，但现阶段，这个可以作为我们分析逃逸现象的依据。 123456789101112type User struct &#123; roles []string&#125;func (u *User) SetRoles(roles []string) &#123; u.roles = roles&#125;func SetRoles(u User, roles []string) User &#123; u.roles = roles return u&#125; 12345678910111213141516171819202122232425type User struct &#123; A []string&#125;func (u *User) Set(a []string) &#123; u.A = a&#125;func SetUser(user User, a []string) User &#123; user.A = a return user&#125;func BenchmarkUser(b *testing.B) &#123; // BenchmarkUser-4 39182143 29.0 ns/op //u := new(User) //for i := 0; i &lt; b.N; i++ &#123; // u.Set([]string&#123;&quot;a&quot;&#125;) //&#125; // BenchmarkUser-4 1000000000 0.585 ns/op for i := 0; i &lt; b.N; i++ &#123; _ = SetUser(User&#123;&#125;, []string&#123;&quot;a&quot;&#125;) &#125;&#125; 总结 大多数情况下，性能优化都会为程序带来一定的复杂度。建议实际项目中还是怎么方便怎么写，功能完成后通过性能分析找到瓶颈所在，再对局部进行优化。 多级间接赋值会导致 Go 编译器出现不必要的逃逸，在一些情况下可能我们只需要修改一下数据结构就会使性能有大幅提升。这也是很多人不推荐在 Go 中使用指针的原因，因为它会增加一级访问路径，而 map, slice, interface{}等类型是不可避免要用到的，为了减少不必要的逃逸，只能拿指针开刀了。 参考链接 达菲格-Go 语言内存管理（三）：逃逸分析","raw":null,"content":null},{"title":"Golang 初级技术","date":"2020-12-27T20:18:15.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/golang-primary-interview.html","permalink":"http://muzig.github.io/drafts/golang-primary-interview.html","excerpt":"最近需要答辩, 收集了部分来自各方的实战面试内容, 便于巩固.\n如有不当之处，请予指正 🙏.","text":"最近需要答辩, 收集了部分来自各方的实战面试内容, 便于巩固. 如有不当之处，请予指正 🙏. TODO 参考链接 基础篇 概念篇 框架篇 开源框架 数据库篇 线上经验 编程题 实现字符串匹配检查 实现一种或多种负载均衡算法 TODO 尽可能完善题目答案 参考链接 ShowMeBug-初级 Golang 面试视频 基础篇 new 和 make 的区别? 都是用于分配内存, 区别在于: 前者主要用于创建返回类型的指针引用; 后者只能用于 slice / map / channel 的初始化. 补充: 其实 new 不常用, 相比较下字面量初始化的方式更为常用, 同时获取指针引用之后, 对于对象的赋值, 还会导致间接赋值的逃逸问题 函数调用传引用类型还是值类型? (涉及逃逸问题) 一般采用引用类型, 少数采用值类型, 这里主要参考的是: 函数内需要或者不需要修改引用类型的值; 其他情况考虑逃逸的问题, 若函数是变量, 则函数参数是引用的话, 会导致函数变量逃逸. 反射的原理? (如何解析 struct 的 tag) recover 能捕获子 goroutine 的 panic 吗? 锁相关的使用情况? 自己使用 channel 的使用场景以及坑? 概念篇 内存管理 线程协程的占用内存大小? 进程模型 进程状态转换 线程模型 线程如果发生 OOM 如何排查处理? 同理 goroutine 发生 OOM ? 调度逻辑 什么时候 goroutine 阻塞? 调度器如何处理? goroutine 一直占用资源如何处理? 框架篇 项目中如何错误处理? 会自定义 error 错误处理吗? gRPC 使用情况? 服务发现/负债均衡的实现? proto 文件如何管理? (monorepo 尝试) 如果中心节点挂掉如何处理? (Raft算法保证可靠性) 开源框架Web: gin beego Gin 中的自定义参数校验规则? Gin 中间件的使用情况 Game: leaf origin leaf 的消息路由方式? 数据库篇 mongodb mysql redis redis mongodb mysql 的锁机制? redis 的基本内容, 使用情况? redis 持久性如何处理? mysql ORM使用情况? (XORM / GORM) mysql 分库分表情况? (分片存储, HBase存储) 主从模式/集群模式/哨兵模式区别? 线上经验 线上 bug 如何排查? 如何分析线上性能瓶颈? 编程题实现字符串匹配检查正确输出以下结果: 即需要同时成对的符号, 即判断成功 123&quot;[()]&quot; =&gt; true&quot;[(]&quot; =&gt; false&quot;&#123;]]&quot; =&gt; false 实现一种或多种负载均衡算法","raw":null,"content":null},{"title":"Golang Scheduling","date":"2020-12-26T15:40:47.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/golang-scheduling.html","permalink":"http://muzig.github.io/drafts/golang-scheduling.html","excerpt":"熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.","text":"熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑. GPM 模型 调度流程 用户方式阻塞/唤醒 syscall sysmon 抢占式调度 netpoll g 的创建流程 g 的暂停方式 Go 调度查看方式 总结 参考链接 GPM 模型文件位置: src/runtime/runtime2.go g(goroutine): 对应到 g 结构体, 保存 goroutin 需要的堆栈信息 p(process): 相当于 g 的驱动, 只有绑定在 local runq 下, 才能被调度 m(machine): \bOS 线程抽象, 真正的驱动力, 和某个 p 绑定, 然后 p 从 local runq 中依次取出 g 用来执行 补充: 最早 go1.1 仅仅是 GM 模式, 后续 Dmitry Vyukov 为了解决并发伸缩性问题, 引入 p 的概念 提案文档 g 的数量受限于 GOMAXPROCS, 即超线程数量, 一般 intel cpu 具有超线程技术, 双核四线程, 即数量为4 m 的个数是不定的，由Go Runtime调整，默认最大限制为10000个 调度流程 m 与 p 绑定, m 从 p 的 local runq 中取出并切换到 g 的堆栈执行 若 local runq 存在 g, 则执行(无锁) 若不存在, 从 global runq 取出 g 执行(有锁) 若依然不存在, 则从其他 p “窃取” g 执行 若没有 g 可以执行, 则 m 与 p 解绑, 进入休眠模式(idle) 用户方式阻塞/唤醒阻塞: 当 g 被 channel 卡住, m 会跳过执行下一个, 并将 g 放置在 waitq 里面 唤醒: 当 g 执行的时候, 通过 channel 向另一个 g2 投递消息, 则 g2 将直接”插队”, 放下一个执行 syscall若 g 被阻塞在一个系统调用上, 则 p 将于 m 解绑, 寻找 idle 状态的 m 再此绑定; 若没有 idle 状态的 m, 则创建一个新的 m. 系统调用结束, g 会重新寻找 idle 状态的 p, 并恢复执行, 若没有则放到 globl runq 中. 系统被调度的两个关键点: runtime/syscall包中, 系统调用分为 syscall &amp; rawsyscall, 区别在于前者会记录保存和恢复所需状态, 这样可以安全的解绑; 某些系统调用可以预先评估是会长时间阻塞, 则会发起之前, 直接 p &amp; m 解绑(handoffp) sysmon 负责检查系统调用时间, 决定是否需要 handoffp sysmonsysmon 是一个由 runtime 启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次. 流程如下: 释放闲置超过5分钟的span物理内存； 如果超过2分钟没有垃圾回收，强制执行； 将长时间未处理的netpoll结果添加到任务队列； 向长时间运行的G任务发出抢占调度； 收回因syscall长时间阻塞的P； 抢占式调度当某个 g 执行超过10ms, 则 sysmon 将发起抢占式请求, 会给 g 打上标签; 当 g 执行函数时(更确切说，在通过newstack分配函数栈时), 将被 runtime.Goched 的方式暂停, 放置在 global runq 中 netpoll除了之前提到的, local runq, runqnext, global runq, 还存在对网络 I/O 进行优化的 netpoll, 本地避免网络I/O的时候陷入系统调用, 不阻塞 M (而是阻塞 G ), 从而不会导致大量的 M 被创建 g 的创建流程 当 go func(){} 执行的时候, 会尝试从池子中复用, 没有则创建 尝试”插队”, 放置到当前 p 的 runnext 里面 否则放置到 local runq 中(无锁) 否则放置到 global runq 中(有锁) g 的暂停方式 常规方式 - 将 g 阻塞, 放到 global runq 中, 等待被获取执行 等待方式 - 将 g 阻塞, 放到 waitq 中, 等待被其他 g 唤醒 自旋方式 - gpm 都不调度, 直到被唤醒 退出方式 - 立即终止 g 任务, 确保 defer 正常执行 process 方式 - 放飞 p, 阻塞 g m, p 可以跟其他 m 绑定 Go 调度查看方式 Go 调度模型 总结从调度模型, 到 gpm 的探讨, 讲到了阻塞和唤醒的流程, 以及如何抢占, 延伸到 sysmon 服务的特点; 最后补充了 netpoll 优化和 g 的创建流程和状态介绍.回过头来, 我们再看看, 学习调度的目的其实实际需求来讲, 就是编写更加高效的并发程序, 明白了流程, 还需要实战, 后续再更新代码实战的情况. 参考链接 Go 调度模型 再谈调度 达菲格-Go 语言调度（一）: 系统调度 达菲格-Go 语言调度（二）: goroutine 调度器 达菲格-Go 语言调度（三）: 并发","raw":null,"content":null},{"title":"Golang 中高级技术","date":"2021-01-24T21:38:41.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/golang-senior-interview.html","permalink":"http://muzig.github.io/drafts/golang-senior-interview.html","excerpt":"之前有了初级技术, 接下来总结一下关于中高级开发的技术要求","text":"之前有了初级技术, 接下来总结一下关于中高级开发的技术要求 TODO 流程 友情链接 TODO后续再俩梳理, 目前看了一遍发现自己真的基础太欠缺了, 对于底层的实现机制来说, 还有很多需要涉猎, 不过其实对于开发来说, 涉及面其实少. 后面要注重代码的性能分析, 以及代码开发效率和质量相关问题的分析, 个人排序: 开发质量(易查错, 健壮性) &gt; 开发效率 &gt; 性能 整理文档 流程 自我介绍 代码效率分析，考察局部性原理 多核CPU场景下，cache如何保持一致、不冲突？ uint类型溢出 介绍rune类型 编程题：3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上100次。 介绍一下channel，无缓冲和有缓冲区别 是否了解channel底层实现，比如实现channel的数据结构是什么？ channel是否线程安全？ Mutex是悲观锁还是乐观锁？悲观锁、乐观锁是什么？ Mutex几种模式？ Mutex可以做自旋锁吗？ 介绍一下RWMutex 项目中用过的锁？ 介绍一下线程安全的共享内存方式 介绍一下goroutine goroutine自旋占用cpu如何解决（go调用、gmp） 介绍linux系统信号 goroutine抢占时机（gc 栈扫描） Gc触发时机 是否了解其他gc机制 Go内存管理方式 Channel分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？ 介绍一下大对象小对象，为什么小对象多了会造成gc压力？ 项目中遇到的oom情况？ 项目中使用go遇到的坑？ 工作遇到的难题、有挑战的事情，如何解决？ 如何指定指令执行顺序？ 友情链接 中高级Golang","raw":null,"content":null},{"title":"My Mac","date":"2021-02-03T23:38:39.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/oh-my-mac.html","permalink":"http://muzig.github.io/drafts/oh-my-mac.html","excerpt":"整理从0到1使用Mac系统, 提高生产力第一步, 学会良好的使用工具.","text":"整理从0到1使用Mac系统, 提高生产力第一步, 学会良好的使用工具. 今天由于电池问题, 换了一波电脑, big sur系统, 之前打算升级来着一直怕有兼容性问题, 不过今天实际体验了下, 目前没有遇到什么问题, 这里顺带写一些装电脑细节, 便于快速整理恢复系统细节. TODO Terminal Homebrew iTerm2 zsh 软件篇 必备 工具 程序开发 其他细节 iTerm2 Goland Tmux oh-my-zsh 友情链接 TODO Terminal 软件篇 其他细节 TerminalHomebrew1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; iTerm21brew install --cask iterm2 zsh 安装 1brew install zsh &amp;&amp; chsh -s usr/local/bin/zsh 插件 ohmyzsh 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 12345678910111213brew install autojumpbrew install fzfbrew install gitbrew install git-lfsbrew install tmuxbrew install vimbrew install wgetbrew install telnetbrew install rlwrap 软件篇必备123456brew install --cask google-chromebrew install --cask dingtalkbrew install --cask wechatbrew install --cask qqbrew install --cask sogouinputbrew install --cask neteasemusic 印象笔记 工具1234brew install --cask appcleanerbrew install --cask [dozer](https://github.com/Mortennn/Dozer)brew install --cask snipastebrew install --cask tencent-lemon 程序开发123456brew install --cask golandbrew install --cask dockerbrew install --cask postmanbrew install --cask robo-3tbrew install --cask visual-studio-codebrew install --cask unity-hub 其他细节iTerm2 Alt + b / f 无法使用问题 Goland ideaVim快捷键冲突, 或者不生效的修改. Tmuxoh-my-zsh autojump 1brew install autojump zsh-autosuggestion 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions zsh-syntax-highlighting 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 123456789101112131415161718192021222324252627282930313233# Which plugins would you like to load?# Standard plugins can be found in $ZSH/plugins/# Custom plugins may be added to $ZSH_CUSTOM/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=( git git-flow git-auto-fetch git-lfs git-prompt github vscode tmux timer golang fzf autojump zsh-syntax-highlighting zsh-autosuggestions)source $ZSH/oh-my-zsh.shsource ~/.gvm/scripts/gvm# User configuration# export golangexport PATH=$PATH:$HOME/go/go1.13/binexport PATH=$PATH:$HOME/go/bin 友情链接 左岸博客 - zsh插件推荐 FungLeo - mac 下使用 iTerm 终端工具无法使用 alt+b 和 alt+f 快捷键的解决方法","raw":null,"content":null},{"title":"raspberryPi 入门","date":"2021-01-23T21:54:28.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/raspberryPi-note.html","permalink":"http://muzig.github.io/drafts/raspberryPi-note.html","excerpt":"之前在储备前端技术, 目前使用树莓派来搭建开发环境, 便于测试.","text":"之前在储备前端技术, 目前使用树莓派来搭建开发环境, 便于测试. TODO 购买建议 初次使用 初次启动 必会命令 如何搭建LAMP环境 如何搭建开发环境 友情链接 TODO 完善文档 购买建议准备: 树莓派4b 设备电源 microHDMI转HDMI 或 转VGA 读卡器 micro-SD卡(8G,16G, 32G) 任意即可 键盘 显示器 初次使用 下载iso镜像 烧录进micro-sd 将micro-sd插入树莓派(不是用读卡器插入usb接口, 而是有一个专门的插入micro-sd的位置) 直接启动, 即可进入界面 123456# mac 烧录方式# 在Mac OS下SD卡的设备名一般为rdisk*，可以用diskutil list命令查看。# 在Linux下SD卡的设备名一般为sd*，可以用lsblk命令查看。sudo dd bs=1m if=&lt;下载的镜像.img&gt; of=/dev/&lt;SD卡设备名&gt; conv=sync# 报错提醒: dd: /dev/disk2: Resource busy# 则执行 diskutil umountDisk /dev/disk2 初次启动 设置区域, 开启wifi功能 连接wifi 设置root密码 12345# 设置相关参数sudo raspi-config# 设置root密码sudo passwd root 必会命令如何搭建LAMP环境如何搭建开发环境友情链接 如何给树莓派安装操作系统 如何方便的烧录镜像","raw":null,"content":null},{"title":"Mac 同步文件到 Linux","date":"2021-03-21T18:48:48.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/scp.html","permalink":"http://muzig.github.io/drafts/scp.html","excerpt":"scp – secure copy (remote file copy program)","text":"scp – secure copy (remote file copy program) 基本用法 Mac 上传文件到Linux 12# scp + 文件路径 + 用户名@服务器地址:目标路径scp tmp.md root@192.168.0.1:/root/ 2、Linux 下载文件到 Mac 12# scp 用户名@服务器地址:目标路径 下载路径scp root@192.168.0.1:/root/tmp.md ~/Desktop/ 参数说明 -r: Recursively copy entire directories. Note that scp follows symbolic links encountered in the tree traversal. -P(port): Specifies the port to connect to on the remote host.","raw":null,"content":null},{"title":"Shell 笔记","date":"2020-12-19T15:22:53.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/shell-note.html","permalink":"http://muzig.github.io/drafts/shell-note.html","excerpt":"在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务.\n科技改变生活, 脚本释放双手.","text":"在项目中开发过程中, 难免会处理一些脚本化的业务, 编写 shell 脚本能帮助我们更方便的处理一些固定业务. 科技改变生活, 脚本释放双手. 基础语法 变量 字符串 数组 注释 传参 运算符 算数运算符 逻辑运算符 布尔运算符 关系运算符 字符串运算符 文件测试运算符 流程控制 条件控制 循环控制 函数 重定向 /dev/null 文件 文件引用 oh-my-zsh 源码 参考链接 基础语法变量123# 赋值等号两边不能添加空格name=&#x27;hello&#x27;echo $&#123;name&#125; 123# 常量name=&#x27;hello&#x27;readonly name 123# 删除变量name=&#x27;hello&#x27;unset name 字符串 单引号 原样输出, 不支持变量引用 双引号 支持变量引用 支持转义字符 123# 获取字符串长度name=&#x27;hello&#x27;echo $&#123;#name&#125; 123# 提取字符串name=&#x27;hello world&#x27;echo $&#123;name:1:3&#125; # 输出ell 123# 查找字符串string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 数组123array_name=(value1 value2 ... valuen)# 访问v1=$&#123;array_name[0]&#125; 注释1234567# 单行注释:&lt;&lt;EOF多行注释多行注释EOF符号可以换成其他, 比如`&#x27;之类的EOF 传参 $0: 文件名 $1: 命令行执行的第一个参数 $2: 命令行执行的第二个参数 运算符算数运算符 逻辑运算符 布尔运算符 关系运算符 字符串运算符 文件测试运算符 流程控制关键字: break continue 条件控制12345678910111213# 多行if condition1then command1elif condition2 then command2else commandNfi# 单行if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 循环控制1234567891011# 多行for var in item1 item2 ... itemNdo command1 command2 ... commandNdone# 单行for var in item1 item2 ... itemN; do command1; command2… done; 1234567891011121314151617# 条件循环while conditiondo commanddone# 条件循环until conditiondo commanddone# 无限循环while :do commanddone 函数12345678910# 语法[ function ] funname [()]&#123; action; [return int;]&#125; 123456demoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 1234输出结果:-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 重定向 /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1command &gt; /dev/null 文件引用1url=&quot;http://muzig.github.io&quot; 1234567# 使用 . 号来引用src.sh 文件. ./src.sh# 或者使用以下包含文件代码source ./src.shecho &quot;Blog：$url&quot; 12输出:Blog: http://muzig.github.io oh-my-zsh 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# If ZSH is not defined, use the current script&#x27;s directory.[[ -z &quot;$ZSH&quot; ]] &amp;&amp; export ZSH=&quot;$&#123;$&#123;(%):-%x&#125;:a:h&#125;&quot;# Set ZSH_CACHE_DIR to the path where cache files should be created# or else we will use the default cache/if [[ -z &quot;$ZSH_CACHE_DIR&quot; ]]; then ZSH_CACHE_DIR=&quot;$ZSH/cache&quot;fi# Check for updates on initial load...if [ &quot;$DISABLE_AUTO_UPDATE&quot; != &quot;true&quot; ]; then source $ZSH/tools/check_for_upgrade.shfi# Initializes Oh My Zsh# add a function pathfpath=($ZSH/functions $ZSH/completions $fpath)# Load all stock functions (from $fpath files) called below.autoload -U compaudit compinit# Set ZSH_CUSTOM to the path where your custom config files# and plugins exists, or else we will use the default custom/if [[ -z &quot;$ZSH_CUSTOM&quot; ]]; then ZSH_CUSTOM=&quot;$ZSH/custom&quot;fiis_plugin() &#123; local base_dir=$1 local name=$2 builtin test -f $base_dir/plugins/$name/$name.plugin.zsh \\ || builtin test -f $base_dir/plugins/$name/_$name&#125;# Add all defined plugins to fpath. This must be done# before running compinit.for plugin ($plugins); do if is_plugin $ZSH_CUSTOM $plugin; then fpath=($ZSH_CUSTOM/plugins/$plugin $fpath) elif is_plugin $ZSH $plugin; then fpath=($ZSH/plugins/$plugin $fpath) else echo &quot;[oh-my-zsh] plugin &#x27;$plugin&#x27; not found&quot; fidone# Figure out the SHORT hostnameif [[ &quot;$OSTYPE&quot; = darwin* ]]; then # macOS&#x27;s $HOST changes with dhcp, etc. Use ComputerName if possible. SHORT_HOST=$(scutil --get ComputerName 2&gt;/dev/null) || SHORT_HOST=$&#123;HOST/.*/&#125;else SHORT_HOST=$&#123;HOST/.*/&#125;fi# Save the location of the current completion dump file.if [ -z &quot;$ZSH_COMPDUMP&quot; ]; then ZSH_COMPDUMP=&quot;$&#123;ZDOTDIR:-$&#123;HOME&#125;&#125;/.zcompdump-$&#123;SHORT_HOST&#125;-$&#123;ZSH_VERSION&#125;&quot;fi# Construct zcompdump OMZ metadatazcompdump_revision=&quot;#omz revision: $(builtin cd -q &quot;$ZSH&quot;; git rev-parse HEAD 2&gt;/dev/null)&quot;zcompdump_fpath=&quot;#omz fpath: $fpath&quot;# Delete the zcompdump file if OMZ zcompdump metadata changedif ! command grep -q -Fx &quot;$zcompdump_revision&quot; &quot;$ZSH_COMPDUMP&quot; 2&gt;/dev/null \\ || ! command grep -q -Fx &quot;$zcompdump_fpath&quot; &quot;$ZSH_COMPDUMP&quot; 2&gt;/dev/null; then command rm -f &quot;$ZSH_COMPDUMP&quot; zcompdump_refresh=1fiif [[ $ZSH_DISABLE_COMPFIX != true ]]; then source $ZSH/lib/compfix.zsh # If completion insecurities exist, warn the user handle_completion_insecurities # Load only from secure directories compinit -i -C -d &quot;$&#123;ZSH_COMPDUMP&#125;&quot;else # If the user wants it, load from all found directories compinit -u -C -d &quot;$&#123;ZSH_COMPDUMP&#125;&quot;fi# Append zcompdump metadata if missingif (( $zcompdump_refresh )); then # Use `tee` in case the $ZSH_COMPDUMP filename is invalid, to silence the error # See https://github.com/ohmyzsh/ohmyzsh/commit/dd1a7269#commitcomment-39003489 tee -a &quot;$ZSH_COMPDUMP&quot; &amp;&gt;/dev/null &lt;&lt;EOF$zcompdump_revision$zcompdump_fpathEOFfiunset zcompdump_revision zcompdump_fpath zcompdump_refresh# Load all of the config files in ~/oh-my-zsh that end in .zsh# TIP: Add files you don&#x27;t want in git to .gitignorefor config_file ($ZSH/lib/*.zsh); do custom_config_file=&quot;$&#123;ZSH_CUSTOM&#125;/lib/$&#123;config_file:t&#125;&quot; [ -f &quot;$&#123;custom_config_file&#125;&quot; ] &amp;&amp; config_file=$&#123;custom_config_file&#125; source $config_filedone# Load all of the plugins that were defined in ~/.zshrcfor plugin ($plugins); do if [ -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh elif [ -f $ZSH/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH/plugins/$plugin/$plugin.plugin.zsh fidone# Load all of your custom configurations from custom/for config_file ($ZSH_CUSTOM/*.zsh(N)); do source $config_filedoneunset config_file# Load the themeif [ ! &quot;$ZSH_THEME&quot; = &quot;&quot; ]; then if [ -f &quot;$ZSH_CUSTOM/$ZSH_THEME.zsh-theme&quot; ]; then source &quot;$ZSH_CUSTOM/$ZSH_THEME.zsh-theme&quot; elif [ -f &quot;$ZSH_CUSTOM/themes/$ZSH_THEME.zsh-theme&quot; ]; then source &quot;$ZSH_CUSTOM/themes/$ZSH_THEME.zsh-theme&quot; else source &quot;$ZSH/themes/$ZSH_THEME.zsh-theme&quot; fifi 参考链接 阮一峰的《Bash 脚本教程》 Shell 教程 | 菜鸟教程","raw":null,"content":null},{"title":"The art of command line","date":"2021-01-31T21:59:48.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/the-art-of-command-line.html","permalink":"http://muzig.github.io/drafts/the-art-of-command-line.html","excerpt":"在此回顾一下命令行的高效使用方式, 提高日常操作流程.","text":"在此回顾一下命令行的高效使用方式, 提高日常操作流程. TOOD 基础 日常使用 TOOD 基础 日常使用 文件以及数据处理 系统调试 单行脚本 冷门但有用 仅限OSX系统 基础 通读man bash 熟悉vim 学会man, apropos, type, shell别名等 学会重定向管道; 明白输出文件&gt;&gt;; stdout, stdin, stderr; 学会通配符 * ? [ … ], ‘ “ 区别 熟悉bash的任务管理工具; &amp;, nohup, ctrl-z, ctrl-c, jobs, fg, bg, kill 熟悉ssh登陆, ssh-agent, ssh-add无密码认证登陆 基本文件管理工具 ls, ls -l less, head, tail, tail -F, less +F ln, ln -s (软硬链接的区别) df, mount, fdisk, mkfs, lsblk 知道inode是什么; ls -i, df -i 等命令相关 网络管理工具 ip, ifconfig dig 版本控制git, svn, 以及oh-my-zsh里面的alias 熟悉正则表达, grep, egrep, zgrep -ABC -v -i -o -r 学会管理工具使用, apt, yum, dnf, pacman, pip3 日常使用 Tab自动补全 ctrl-r, ctrl-w, ctrl-u, ctrl-a, ctrl-e, ctrl-k, ctrl-l alt-b, alt-f alt-., alt-* man readline set -i vi | set -i emacs export EDITOR=vim ctrl-x ctrl-e escape-v history !n !$ !! HISTORY EXPANSION cd ~, $HOME, cd - xargs | parallel 结合 awk xargs -I {} echo {} pstree -p 进程树 pgrep, pkill kill -STOP [pid] man 7 signal nohup, disown netstat -lntp | ss -plat -u lsof -iTCP -sTCP:LISTEN -P -n lsof查看套接字和文件 uptime | w seq alias alias ll=’ls -latr’ 别名保存在~/.bashrc 环境变量保存在~/.bash_profile 变量名和文件名包含空格, 需要使用引号包括起来","raw":null,"content":null},{"title":"vue.js 纪录片","date":"2021-01-29T21:19:57.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/the-documentary-of-vue.html","permalink":"http://muzig.github.io/drafts/the-documentary-of-vue.html","excerpt":"值得一看. Click Here","text":"值得一看. Click Here","raw":null,"content":null},{"title":"tmux 快速指北","date":"2021-01-30T09:52:48.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/tmux.html","permalink":"http://muzig.github.io/drafts/tmux.html","excerpt":"如果您用过screen的话, 相比知道它的好处, 这里记录一款类似的工具tmux.","text":"如果您用过screen的话, 相比知道它的好处, 这里记录一款类似的工具tmux. TODO 🚀 快速搭建 常用快捷键 插件 oh-my-tmux tmux-resurrect 友情链接 TODO 常用快捷键 🚀 快速搭建 Install Tmux: 12345678# macbrew install tmux# linux - RedHatyum install tmux# linux - Debianapt install tmux Clone TPM: 1git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm Put this at the bottom of ~/.tmux.conf ($XDG_CONFIG_HOME/tmux/tmux.conf works too): 123456# 推荐配置git clone https://github.com/gpakosz/.tmux.git ~/.tmux/oh-my-tmux/cp ~/.tmux/oh-my-tmux/.tmux.conf ~/# 自定义配置wget https://github.com/muzig/oh-my-mac/blob/main/tmux/.tmux.conf ~/.tmux.conf.local Reload TMUX environment so TPM is sourced: 12# type this in terminal if tmux is already running$ tmux source ~/.tmux.conf 常用快捷键插件oh-my-tmux作用: 通用tmux配置搭配 123git clone https://github.com/gpakosz/.tmux.gitln -s -f .tmux/.tmux.confcp .tmux/.tmux.conf.local . tmux-resurrect作用: 保存tmux的layout, 便于重启电脑快速恢复. Add plugin to the list of TPM plugins in .tmux.conf: Hit prefix + I to fetch the plugin and source it. You should now be able to use the plugin. 1set -g @plugin &#x27;tmux-plugins/tmux-resurrect&#x27; 友情链接 TPM oh-my-tmux tmux-resurrect","raw":null,"content":null},{"title":"TypeScript 笔记","date":"2021-01-10T19:16:43.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/ts-note.html","permalink":"http://muzig.github.io/drafts/ts-note.html","excerpt":"对于需要掌握前端技术, 对于 ts 的基础语法掌握也是必不可少的. 利于读懂前端源码.","text":"对于需要掌握前端技术, 对于 ts 的基础语法掌握也是必不可少的. 利于读懂前端源码. TODO 速览 基础类型 字符串 数组 元组 Tuple 枚举 Void null &amp; undefined Never Object Any 类型断言 关于let 变量声明 var声明 let声明 const声明 解构 数组解构 对象解构 展开(与解构相反操作) 数组展开 对象展开 接口 接口定义 形参约束 可选参数 只读参数 关闭额外类型检查 函数类型 可索引的类型 类继承接口 接口继承 混合类型 接口继承类 TODO 速览 基础类型 变量声明 接口 函数 泛型 枚举 类型推导 类型兼容性 高级类型 Symbols 迭代器和生成器 模块 命令空间 命令空间和模块 模块解析 声明合并 JSX 装饰器 Mixins 三斜线指令 JS文件类型检查 速览 官方手册指南 类型注解 ts 支持静态类型检查, 便于在运行之前, 提前发现代码问题. 123456function hello(name: string) &#123; return &quot;hello&quot; + name;&#125;let flag = &quot;ts&quot;;hello(flag); 接口 执行约束 object 类型的格式, 便于保证函数按照预期执行 12345678910interface Person &#123; firstName: string; lastName: string;&#125;function say(p: Person) &#123; return p.firstName + p.lastName;&#125;let user = &#123; firstName: &quot;xiao&quot;, lastName: &quot;ming&quot; &#125;;say(user); 类 提供面向对象编程的思想, 具体更多抽象能力 1234567891011121314151617class Student &#123; fullName: string; constructor(public firstName: string, public lastName: string) &#123; this.fullName = firstName + lastName; &#125;&#125;interface Person &#123; firstName: string; lastName: string;&#125;function say(p: Person) &#123; return p.firstName + p.lastName;&#125;let user = new Student(&quot;xiao&quot;, &quot;ming&quot;);say(user); 补充 ts &amp; js 对大小写敏感; 对于属性名建议取名为小写, 因为 typeof 返回的类型名为小写. 基础类型字符串123// 字符串let name: string = &quot;TypeScript&quot;let sentence: string = `Hello $&#123; name &#125;.` 数组123// 数组let arr: number[] = [1,2,3]let arr: Array&lt;number&gt; = [1,2,3] // 泛型数组 元组 Tuple1234567891011121314// 元组 Tuple// Declare a tuple typelet x: [string, number];// Initialize itx = [&#x27;hello&#x27;, 10]; // OK// Initialize it incorrectlyx = [10, &#x27;hello&#x27;]; // Errorconsole.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, &#x27;number&#x27; does not have &#x27;substr&#x27;x[3] = &#x27;world&#x27;; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 枚举更好的描述一组数值 12345678910// 默认从0开始为元素编号// 支持手动赋值enum Color &#123; Red, Green, Blue = 3&#125;let c: Color = Color.Green// 支持打印枚举名let colorName: string = Color[2] console.log(colorName)// 输出:// Color Void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null null &amp; undefined然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。 注意：我们鼓励尽可能地使用–strictNullChecks 12let u: undefined = undefinedlet n: null = null Nevernever类型表示的是那些永不存在的值的类型。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）. 即使 any也不可以赋值给never。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 123456789declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(&quot;string&quot;); // Errorcreate(false); // Errorcreate(undefined); // Error Any对于暂时无法预期的类型, 可以使用 any 去描述 123456let msg: any = 100msg = true // OKmsg = &quot;foo&quot; // OKlet arr: any[] = [1, &quot;foo&quot;, &quot;boo&quot;]arr[1] = 100 // OK 类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。 1234567// 第一种写法: 尖括号let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;// 第二种写法: as语法let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 关于let你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。 变量声明var声明 作用域规则 捕获变量特殊之处 let声明 块作用域 重定义屏蔽 块级作用域变量获取 - 通过闭包 const声明 声明之后不能修改; 但是可以修改对象内部值 解构数组解构 让数组变量更清晰 支持函数参数解构格式 支持…语法创建剩余变量 对象解构 结构化对象成员 …语法支持结构余下对象成员 支持结构化之后重命名 =语法支持缺省默认值 函数声明支持结构对象 展开(与解构相反操作)数组展开1234let first = [1, 2];let second = [3, 4];// 浅拷贝let bothPlus = [0, ...first, ...second, 5]; 对象展开12let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123; ...defaults, food: &quot;rich&quot; &#125;; 1234let obj: object = &#123; a: &quot;a&quot;, b: &quot;b&quot; &#125;;let obj2: object = &#123; ...obj, a: &quot;b&quot; &#125;; // 不会重写 a 成员值 =&gt; a = &quot;b&quot;let obj2: object = &#123; a: &quot;b&quot;, ...obj &#125;; // 会重写 a 成员值 =&gt; a = &quot;a&quot;console.log(obj2); 对象展开还有其它一些意想不到的限制 扩展之后, 会丢失了成员函数 tsc不允许展开泛型函数上的类型参数 123456789class C &#123; p = 12; m() &#123; &#125;&#125;let c = new C();let clone = &#123; ...c &#125;;clone.p; // okclone.m(); // error! 接口接口定义形参约束可选参数只读参数关闭额外类型检查函数类型可索引的类型 TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 类继承接口 类静态部分, 需要使用形参约束的方式去约束, 比如构造函数 接口继承混合类型接口继承类 extends implements","raw":null,"content":null},{"title":"uni-app 入门","date":"2021-03-05T15:10:44.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/uni-app.html","permalink":"http://muzig.github.io/drafts/uni-app.html","excerpt":"最近需要搭建前端界面, 熟悉一下前端框架.","text":"最近需要搭建前端界面, 熟悉一下前端框架. 前言 准备 搭建项目代码 搭建本地服务 遇到的问题 跨域问题 前言最早了解到vue, 大概浏览了一番评价都是挺好的, 而且容易上手, 所以顺势找到了多端开发框架uni-app, 基于vue来实现的, 所以这次探索从uni-app开始. 持续更新… 准备 搭建项目 - 根据官方文档 搭建本地服务 - 使用golang搭建本地http服务, 用于测试 搭建项目代码12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;u-button @click=&quot;onTest&quot;&gt;点我&lt;/u-button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; title: &quot;Hello&quot;, text: &quot;&quot;, &#125;; &#125;, onLoad() &#123;&#125;, methods: &#123; onTest: function () &#123; // 使用uni-app内置的请求接口 uni.request(&#123; url: &quot;http://localhost:8081/index&quot;, data: &#123; // text: &quot;uni.request&quot;, &#125;, header: &#123; // &quot;custom-header&quot;: &quot;hello&quot;, //自定义请求头信息 &#125;, success: (res) =&gt; &#123; this.title = &quot;requestOK&quot;; this.text = res.data; &#125;, &#125;); &#125;, &#125;,&#125;;&lt;/script&gt; 搭建本地服务123456func main() &#123; http.HandleFunc(&quot;/index&quot;, func(w http.ResponseWriter, r *http.Request) &#123; _, _ = fmt.Fprintln(w, `&#123;name:\\&quot;xiaoming\\&quot;&#125;`) &#125;) _ = http.ListenAndServe(&quot;:8081&quot;, nil)&#125; 遇到的问题跨域问题 解决方案链接 自己在chrome调试的时候会存在跨域的问题, 文章指出另外运行期间在HBuilderX的内置浏览器里是不存在跨域的, 所以安装了hbuilder的内置浏览器调试.","raw":null,"content":null},{"title":"Vue 笔记","date":"2021-01-16T16:32:05.000Z","updated":"2021-10-05T08:47:00.248Z","comments":true,"path":"drafts/vue-note.html","permalink":"http://muzig.github.io/drafts/vue-note.html","excerpt":"将自学思路整理此处, 便于后续细节回顾.","text":"将自学思路整理此处, 便于后续细节回顾. 源码项目 技术栈 源码项目在了解基本语法之后, 最好的学习方式就是熟悉实战项目的源码, 能较快的获取实战经验. 此处贴 github 开源的实战项目, 很值的一探究竟. 外卖实战项目 外卖后端管理 技术栈有了实战项目, 我们先了解一下我们将用到什么工具, 这样对整个开发过程有一个大局观的感觉. vue2 vuex vue-router webpack ES6/7 fetch sass flex svg","raw":null,"content":null}],"posts":[]}