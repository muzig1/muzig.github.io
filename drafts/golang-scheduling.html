<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Golang Scheduling</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Haojen's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><article id="page"><h1>Golang Scheduling</h1><p>熟悉 Golang 的调度原理, 能够帮助编写更加高效的并发逻辑; 同时还能避免调度相关的坑.</p>
<a id="more"></a>

<ul>
<li><a href="#gpm-%E6%A8%A1%E5%9E%8B">GPM 模型</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B">调度流程</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E6%96%B9%E5%BC%8F%E9%98%BB%E5%A1%9E%E5%94%A4%E9%86%92">用户方式阻塞/唤醒</a></li>
<li><a href="#syscall">syscall</a></li>
<li><a href="#sysmon">sysmon</a></li>
<li><a href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6">抢占式调度</a></li>
<li><a href="#netpoll">netpoll</a></li>
<li><a href="#g-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B">g 的创建流程</a></li>
<li><a href="#g-%E7%9A%84%E6%9A%82%E5%81%9C%E6%96%B9%E5%BC%8F">g 的暂停方式</a></li>
<li><a href="#go-%E8%B0%83%E5%BA%A6%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F">Go 调度查看方式</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><p>文件位置: src/runtime/runtime2.go</p>
<ul>
<li>g(goroutine): 对应到 g 结构体, 保存 goroutin 需要的堆栈信息</li>
<li>p(process):   相当于 g 的驱动, 只有绑定在 local runq 下, 才能被调度</li>
<li>m(machine):   OS 线程抽象, 真正的驱动力, 和某个 p 绑定, 然后 p 从 local runq 中依次取出 g 用来执行</li>
</ul>
<p><img src="/../img/go-shechduling.png" alt="go-sheduling"></p>
<p>补充:</p>
<ol>
<li>最早 go1.1 仅仅是 GM 模式, 后续 Dmitry Vyukov 为了解决<strong>并发伸缩性</strong>问题, 引入 p 的概念 <a target="_blank" rel="noopener" href="https://github.com/muzig/muzig.github.io/blob/main/source/pdf/Scalable%20Go%20Scheduler%20Design%20Doc.pdf">提案文档</a></li>
<li>g 的数量受限于 GOMAXPROCS, 即超线程数量, 一般 intel cpu 具有超线程技术, 双核四线程, 即数量为4</li>
<li>m 的个数是不定的，由Go Runtime调整，默认最大限制为10000个</li>
</ol>
<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><ol>
<li>m 与 p 绑定, m 从 p 的 local runq 中取出并切换到 g 的堆栈执行<ol>
<li>若 local runq 存在 g, 则执行(无锁)</li>
<li>若不存在, 从 global runq 取出 g 执行(有锁)</li>
<li>若依然不存在, 则从其他 p “窃取” g 执行</li>
</ol>
</li>
<li>若没有 g 可以执行, 则 m 与 p 解绑, 进入休眠模式(idle)</li>
</ol>
<h2 id="用户方式阻塞-唤醒"><a href="#用户方式阻塞-唤醒" class="headerlink" title="用户方式阻塞/唤醒"></a>用户方式阻塞/唤醒</h2><p>阻塞:</p>
<p>当 g 被 channel 卡住, m 会跳过执行下一个, 并将 g 放置在 waitq 里面</p>
<p>唤醒:</p>
<p>当 g 执行的时候, 通过 channel 向另一个 g2 投递消息, 则 g2 将直接”插队”, 放下一个执行</p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>若 g 被阻塞在一个系统调用上, 则 p 将于 m 解绑, 寻找 idle 状态的 m 再此绑定; 若没有 idle 状态的 m, 则创建一个新的 m.</p>
<p>系统调用结束, g 会重新寻找 idle 状态的 p, 并恢复执行, 若没有则放到 globl runq 中.</p>
<p>系统被调度的两个关键点:</p>
<ol>
<li>runtime/syscall包中, 系统调用分为 syscall &amp; rawsyscall, 区别在于前者会记录保存和恢复所需状态, 这样可以安全的解绑; 某些系统调用可以预先评估是会长时间阻塞, 则会发起之前, 直接 p &amp; m 解绑(handoffp)</li>
<li>sysmon 负责检查系统调用时间, 决定是否需要 handoffp</li>
</ol>
<h2 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h2><p>sysmon 是一个由 runtime 启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次.</p>
<p>流程如下:</p>
<ol>
<li>释放闲置超过5分钟的span物理内存；</li>
<li>如果超过2分钟没有垃圾回收，强制执行；</li>
<li>将长时间未处理的netpoll结果添加到任务队列；</li>
<li>向长时间运行的G任务发出抢占调度；</li>
<li>收回因syscall长时间阻塞的P；</li>
</ol>
<h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p>当某个 g 执行超过10ms, 则 sysmon 将发起抢占式请求, 会给 g 打上标签; 当 g 执行函数时(更确切说，在通过newstack分配函数栈时), 将被 runtime.Goched 的方式暂停, 放置在 global runq 中</p>
<h2 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h2><p>除了之前提到的, local runq, runqnext, global runq, 还存在对网络 I/O 进行优化的 netpoll, 本地避免网络I/O的时候陷入系统调用, 不阻塞 M (而是阻塞 G ), 从而不会导致大量的 M 被创建</p>
<h2 id="g-的创建流程"><a href="#g-的创建流程" class="headerlink" title="g 的创建流程"></a>g 的创建流程</h2><ol>
<li>当 go func(){} 执行的时候, 会尝试从池子中复用, 没有则创建</li>
<li>尝试”插队”, 放置到当前 p 的 runnext 里面</li>
<li>否则放置到 local runq 中(无锁)</li>
<li>否则放置到 global runq 中(有锁)</li>
</ol>
<h2 id="g-的暂停方式"><a href="#g-的暂停方式" class="headerlink" title="g 的暂停方式"></a>g 的暂停方式</h2><ul>
<li>常规方式  - 将 g 阻塞, 放到 global runq 中, 等待被获取执行</li>
<li>等待方式  - 将 g 阻塞, 放到 waitq 中, 等待被其他 g 唤醒</li>
<li>自旋方式  - gpm 都不调度, 直到被唤醒</li>
<li>退出方式  - 立即终止 g 任务, 确保 defer 正常执行</li>
<li>process 方式 - 放飞 p, 阻塞 g m, p 可以跟其他 m 绑定</li>
</ul>
<h2 id="Go-调度查看方式"><a href="#Go-调度查看方式" class="headerlink" title="Go 调度查看方式"></a>Go 调度查看方式</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wudaijun.com/2018/01/go-scheduler/">Go 调度模型</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从调度模型, 到 gpm 的探讨, 讲到了阻塞和唤醒的流程, 以及如何抢占, 延伸到 sysmon 服务的特点; 最后补充了 netpoll 优化和 g 的创建流程和状态介绍.<br>回过头来, 我们再看看, 学习调度的目的其实实际需求来讲, 就是编写更加高效的并发程序, 明白了流程, 还需要实战, 后续再更新代码实战的情况.</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wudaijun.com/2018/01/go-scheduler/">Go 调度模型</a></li>
<li><a target="_blank" rel="noopener" href="https://wudaijun.com/2018/11/scheduler-blabla/">再谈调度</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/db0aea4d60ed">达菲格-Go 语言调度（一）: 系统调度</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb6881a2661d">达菲格-Go 语言调度（二）: goroutine 调度器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ef654413f2c1">达菲格-Go 语言调度（三）: 并发</a></li>
</ul>
</article><div id="paginator"></div></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/haojen"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Haojen 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script></body></html>